#!/usr/bin/env python
########################################################################
# $Header: /tmp/libdirac/tmp.stZoy15380/dirac/DIRAC3/scripts/Attic/dirac-update,v 1.19 2008/03/27 17:45:40 rgracian Exp $
# File :   dirac-update
# Author : Ricardo Graciani
########################################################################
__RCSID__   = "$Id: dirac-update,v 1.19 2008/03/27 17:45:40 rgracian Exp $"
__VERSION__ = "$Revision: 1.19 $"
"""
    Script to prepare/update a DIRAC instalation
"""
tmpPath = None
try:
  from dirac_functions import *
except:
  try:
    # if dirac_function is not available, retrive DIRAC-scripts tar
    import sys, os, signal
    import tempfile, datetime, urllib, tarfile
    defaultURL = 'http://cern.ch/lhcbproject/dist/DIRAC3'
    tmpPath = tempfile.mkdtemp( 'tmp', 'DIRAC3')
    os.chdir( tmpPath )
    def get_tar( name, timeout ):
      ( file, localName ) = tempfile.mkstemp()
      tarFileName = os.path.join( '%s.tar.gz' % name )
      remoteName = '%s/%s' % ( defaultURL, tarFileName )
      error = 'Retrieving file "%s"' % remoteName
      try:
        urlretrieveTimeout( remoteName, localName, timeout )
        error = 'Opening file "%s"' % localName
        tar = tarfile.open( localName , 'r' )
        try:
          error = 'Extracting file "%s"' % localName
          tar.extractall( tmpPath )
          os.remove( localName )
        except:
          for member in tar.getmembers():
            tar.extract( member, tmpPath )
          os.remove( localName )
    
      except Exception, x:
        try:
          os.remove( localName )
        except:
          pass
        logERROR( error )
        logEXCEP( x )

    def urlretrieveTimeout( fname, lname, timeout ):
      """
       Retrive remore url to local file, with timeout wrapper
      """
      # NOTE: Not thread-safe, since all threads will catch same alarm.
      #       This is OK for dirac-install, since there are no threads.
      logINFO( 'Retrieving remote file "%s"' % fname )
    
      signal.signal(signal.SIGALRM, alarmHandler)
      # set timeout alarm
      signal.alarm(timeout)
      try:
        localname,headers = urllib.urlretrieve( fname, lname )
      except Exception, x:
        if x == 'TimeOut':
          logERROR( 'Timeout after %s seconds on transfer request for "%s"' % \
          (str(timeout), fname) )
        raise x
    
      # clear timeout alarm
      signal.alarm(0)
      
    def alarmHandler(*args):
      """
       signal handler for SIGALRM, just raise an exception
      """
      raise Exception( 'TimeOut' )

    def log( level, msg ):
      """
       Print log entries similar to DIRAC Logger
      """
      shortName = os.path.basename(__file__)
      logTime = str( datetime.datetime.utcnow( ) ).split('.')[0] + " UTC"
      for line in msg.split( '\n' ):
        print logTime, shortName, level, line
    def logEXCEP( msg ):
      log( 'EXCEPT', str(msg) )
      sys.exit( -1 )
    def logERROR( msg ):
      log( 'ERROR ', msg )
    def logINFO( msg ):
      log( 'INFO  ', msg )
    def logDEBUG( msg ):
      log( 'DEBUG ', msg )

    get_tar( 'DIRAC-scripts-HEAD', 60 )
    sys.path.insert( 0, os.path.join( tmpPath, 'scripts' ) )
    
  except Exception, x:
    print x
    sys.exit(-1)

from dirac_functions import *
myFullName  = os.path.realpath( __file__ )
myShortName = os.path.basename( myFullName )

if not tmpPath:
  rootPath = logInit( myFullName )
else:
  rootPath = logInit( os.path.join( tmpPath, 'scripts', myShortName ) )

tarFlag()

platform = get_platform( )

def parse_options():
  """
   parse command line options:
  """
  global platform, rootPath, defaultVersion
  help = """
   -b --build                  Force local compilation
   -d --debug                  Set debug flag
   -e --external=<version>     DIRAC-external <version> to install (overwrites -v)
   -h --help                   Print this
   -i --python=<24|25>         Use python<24|25> interpreter
   -r --repository=<rep>       Use <rep> as cvs repository
   -p --platform=<platform>    Use <platform> instead of local one
   -u --url=<url>              Use <url> to download tarballs
   -v --version=<version>      DIRAC <version> to install
   -C --cvs                    Retrieve from CVS (implies -b)
   -P --path=<root>            Install under <root>

  from DIRAC framework:

    -o --option=<Option=value> <Option=value> to add
    -s --section=<section>     Set base <section> for relative parsed options
    -c --cert=<cert>           Use server certificate <cert> to connect to Core Services

  """
  shortOptions = 'bde:hi:p:u:v:o:s:CP:'
  longOptions  = ['build', 'debug', 'external=', 'help', 'python=', 'platform=', 'url=', 'version=', 
                  'cvs', 'path=',
                  'option=', 'section=']
  try:
    ( optionVals, extraOptions ) = getopt.getopt( sys.argv[1:], shortOptions, longOptions )
  except getopt.GetoptError, x:
    logERROR( 'Parsing command line: %s' % x )
    optionVals = [ ('-h','') ]

  if ('-h','') in optionVals or ('--help','') in optionVals:
    logHelp( help )

  ext = None
  for o,v in optionVals:
    if o == '-b' or o == '--build':
      build()
    elif o == '-d' or o == '--debug':
      debug()
    elif o == '-e' or o == '--external':
      ext = v
    elif o == '-i' or o == '--python':
      set_python(v)
    elif o == '-p' or o == '--platform':
      platform = set_platform(v)
    elif o == '-r' or o == '--repository':
      default_CVS(v)
    elif o == '-u' or o == '--url':
      default_URL( v )
    elif o == '-v' or o == '--version':
      defaultVersion =version(v)
    elif o == '-C' or o == '--cvs':
      cvsFlag()
      build()
    elif o in ('-P', '--path'):
      rootPath = logInit( os.path.join( v, 'scripts', myShortName ) )

    if ext: external(ext)


parse_options()
logINFO( 'Checking DIRAC instalation at "%s"' %  rootPath )
logINFO( 'Using platform "%s"' %  platform )

localPython   = os.path.join( rootPath, platform, 'bin', 'python' )
if not check_interpreter( localPython ):
  install_external( platform )
  localVersion = check_dirac( defaultVersion )
  dirac_magic(  '#! %s' % localPython )
  # if we are not running with our onw python let's call ourself again
  logINFO( 'Will retry now with DIRAC python' )
  args         = str.join(' ',sys.argv[1:]) + ' -v %s' % localVersion
  myScript = os.path.join( rootPath,'scripts', myShortName )
  logDEBUG( '%s %s %s ' % ( localPython, myScript, args ) )
  ret = os.system( '%s %s %s ' % ( localPython, myScript, args ) )
  sys.exit(ret)

else:
  localVersion = check_dirac( defaultVersion )
  dirac_magic(  '#! %s' % localPython )
  from DIRACEnvironment import DIRAC
  if debugFlag:
    DIRAC.gLogger.setLevel( 'DEBUG' )
  else:
    DIRAC.gLogger.setLevel( 'INFO' )
  from DIRAC.Core.Utilities.GridCredentials import setDIRACGroup
  
  setDIRACGroup( 'lhcb_user' )
  
  from DIRAC.Core.Base import Script

  Script.registerSwitch( "b",  "build",     "Allow compilation if platform not available" )
  Script.registerSwitch( "d",  "debug",     "Set debug flag" )
  Script.registerSwitch( "e:", "external=", "DIRAC-external <version> to install" )
  Script.registerSwitch( "i:", "python=",   "Use python<24|25> interpreter" )
  Script.registerSwitch( "p:", "platform=", "Use <platform> instead of local one" )
  Script.registerSwitch( "u:", "url=",      "Use <url> to download tarballs" )
  Script.registerSwitch( "v:", "version=",  "DIRAC <version> to install" )
  Script.registerSwitch( "C",  "cvs",       "Retrieve from CVS (implies -b)" )
  Script.registerSwitch( "P:", "path=",     "Install under <root>" )
  
  from DIRAC.ConfigurationSystem.Client.LocalConfiguration import LocalConfiguration
  localCfg = LocalConfiguration()
  localCfg.addDefaultEntry( '/DIRAC/Setup', 'LHCb-Development' )
  localCfg.addDefaultEntry( '/DIRAC/Configuration/Servers',
                            'dips://lhcbprod.pic.es:9135/Configuration/Server, '
                            'dips://volhcb03.cern.ch:9135/Configuration/Server' )
  
  Script.parseCommandLine( scriptName = myShortName, ignoreErrors = True )
  
  DIRAC.gConfig.dumpLocalCFGToFile( check_diraccfg() )
  # further checks can be implemented here
  logINFO( 'DIRAC version "%s" installed' % localVersion)
  logINFO( 'DIRAC-external version "%s" installed' % externalVersion)

  sys.exit(0)
