#!/usr/bin/env python
"""
    usage: dirac-setup [options] [cfg-file1] [cfg-file2] ...

    options:

        help         h  help
        version      v  version

        site         s <site-name>  DIRAC site name
        mode         m <mode>       DIRAC Agent operating mode

        architecture  a <architecture>  Site architecture (CMTCONFIG)
        platform type p <platform>      Site platform type (LCG,DIRAC,ANY)

    NOTE: use "--" for long options, and "-" for short options
"""

__RCSID__   = "$Id: dirac-setup,v 1.6 2007/12/06 16:16:43 joel Exp $"
__VERSION__ = "$Revision: 1.6 $"

import os, sys, time
import getopt, re
import socket

scriptsPath = os.path.realpath( os.path.dirname( __file__ ) )
rootPath = os.path.realpath( "%s/.." % scriptsPath )

try:
  import DIRAC
except ImportError:
  """
     from the location of the script that import this one (this should only be
     possible if they are in the same directory) tries to setup the PYTHONPATH
  """

  sys.path.insert( 0, rootPath )

  try:
    import DIRAC
  except ImportError:
    print "Can not import DIRAC."
    print "Check if %s contains a proper DIRAC distribution" % rootPath
    raise
    sys.exit(-1)

from DIRAC.ConfigurationSystem.Client.CFG import CFG

cfgLocal = CFG()

def main(argv):

    opts,site,mode,architecture,platform,root = getRSMbase(argv)
    createAgentCFG(opts,site,mode,architecture,platform,root)


def doc():
    print __doc__
    print """
documentation to be provided
    """


def examples():
    print """
Examples to be provided if needed


"""

def createAgentCFG(opts,site,mode,architecture,platform,root):

    #  set the minimal set of option needed to run any agent.

    if not cfgLocal.isSection('DIRAC'):
        print "Creating local section DIRAC"
        cfgLocal.createNewSection('DIRAC','local section')

    cfgAgent = cfgLocal["DIRAC"]
    cfgAgent.setOption('Setup',mode)
    cfgAgent.createNewSection('Configuration')
    cfgAgentCS = cfgAgent["Configuration"]
    cfgAgentCS.setOption('Servers','dips://volhcb03.cern.ch:9135/Configuration/Server')

    if not cfgLocal.isSection('LocalSite'):
        print "Creating local section LocalSite"
        cfgLocal.createNewSection('LocalSite','local site section')

    cfgAgent = cfgLocal["LocalSite"]
    cfgAgent.setOption('Site',site)
    cfgAgent.setOption('Root',root)
    cfgAgent.setOption('Architecture',architecture)
    cfgAgent.setOption('Platform',platform)


    parts = site.split('.')
    if len(parts) != 3:
      print " The site name is not correct. Should be DIRAC.<site>.<country code>"
      sys.exit(-1)
    else:
      sitename = parts[1]

    # write the configuration to a file
    inifile = 'etc/dirac.cfg'
    if not os.path.exists('etc'):
      os.mkdir('etc')
    if os.path.exists(inifile):
      os.remove(inifile)

    fd = open(inifile,'w')
    fd.write(str(cfgLocal))
    fd.close()



def procOpts(argv,site,mode,architecture,platform,root):
    ########################################################################
    # Step 0: Process command line options and arguments
    ########################################################################

    opt_list   = ["help", "version", "debug", "site=", "mode=", "architecture=", "root=", "platform="]
    opts       = {} # this is what we return to the caller
    opt_dict   = {}
    opt_string = ""
    for o in opt_list:
        char = re.match("\w", o).group()
        word = re.match("\w+",o).group()
        val = ""
        if (re.search("=$", o)):
            val = ":"
        opt_dict[char] = ("-" + char, "--" + word)
        opt_string = opt_string + char + val

    try:
        opt_list, remaining_argv   = getopt.getopt(argv[1:], opt_string, opt_list)
    except getopt.GetoptError:
        # print help information and exit:
        print __doc__
        sys.exit(2)

    if (len(remaining_argv) >= 1):
        for j in remaining_argv:
            print j
            cfgLocal.loadFromFile(j)

    ########################################################################
    # Step 1: Use values from command line options
    ########################################################################
    for opt,val in opt_list:
        if   opt in opt_dict['h']:
             print __doc__
             sys.exit(0)
        elif opt in opt_dict['v']:
             print __VERSION__
             sys.exit(0)
        elif opt in opt_dict['s']:
             site           = val
        elif opt in opt_dict['m']:
             mode           = val
        elif opt in opt_dict['a']:
             architecture   = val
        elif opt in opt_dict['r']:
             root   = val
             print rootPath
        elif opt in opt_dict['p']:
             platform   = val
        else:
             print "ERROR: Option %s unknown" % (opt)
             print __doc__
             sys.exit(2)

    return opts,site,mode,architecture,platform,root

def getRSMbase(argv):

    # Default global values in case nothing else is found:
    site = socket.getfqdn()
    mode = 'test'
    root = rootPath
    architecture = 'slc4_ia32_gcc34'
    platform = 'DIRAC'

    opts,site,mode,architecture,platform,root = procOpts(argv,site,mode,architecture,platform,root)

    return opts,site,mode,architecture,platform,root

if __name__ == "__main__":
    main(sys.argv)
