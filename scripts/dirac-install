#!/usr/bin/env python
########################################################################
# $Header: /tmp/libdirac/tmp.stZoy15380/dirac/DIRAC3/scripts/dirac-install,v 1.97 2008/10/17 13:26:45 rgracian Exp $
# File :   dirac-install
# Author : Ricardo Graciani
########################################################################
__RCSID__   = "$Id: dirac-install,v 1.97 2008/10/17 13:26:45 rgracian Exp $"
__VERSION__ = "$Revision: 1.97 $"
"""
    Script to deploy/update a DIRAC installation
"""
try:
  import getopt, sys, os, signal, shutil
  import urllib, popen2, tempfile, fileinput, re, time, stat
except Exception, x:
  import sys
  print 'ERROR python interpreter does not support necessary modules'
  print 'ERROR', x
  print
  sys.exit(-1)

myFullName  = os.path.realpath( sys.argv[0] )
myShortName = os.path.basename( myFullName )

# Some default values that can be changed via options
DIRAC_CVS_REPOSITORY = ':pserver:anonymous@isscvs.cern.ch:/local/reps/dirac'
DIRAC_HTTP_SERVER    = 'http://cern.ch/lhcbproject/dist/DIRAC3'
DIRAC_HTTP_SERVER    = 'http://lhcbweb.pic.es/distribution/DIRAC3'
DIRAC_VERSION        = 'HEAD'
DIRAC_PYTHON         = '24'

# List of native DIRAC platform supported by DIRAC, currently limmited by the 
# availability of LCG python modules
availablePlatforms =  [ # 'Linux_x86_64_glibc-2.5',      # slc5 64 bits
                        'Linux_x86_64_glibc-2.3.4',    # slc4 64 bits
                        'Linux_i686_glibc-2.3.4',      # slc4 32 bits
                        # 'Linux_i686_glibc-2.3.3',      # slc3 32 bits
                        # 'Linux_i686_glibc-2.6',        # ubuntu 7.1 32 bits
                         ]

# version of LCG tarball (with LCG python bindings)
lcgVer = '3.1.14-0'

# conversion between COMTCONFIG (lhcb platforms) and DIRAC platforms
platformDict = { 'slc4_ia32_gcc34' : 'Linux_i686_glibc-2.3.4',
                 'slc4_amd64_gcc34': 'Linux_x86_64_glibc-2.3.4' }


# lists with the list of directories to be include/compile for installations/distributions

src_tars = [ { 'name': 'DIRAC-scripts',
               'packages': ['scripts'],
               'directories': ['scripts']
             },
             { 'name': 'DIRAC',
               'packages': ['DIRAC',
                            'cmt',
                            'DiracSys',
                            'DiracConfig',
                            'DiracHome',
                            'WorkflowLib',
                            'LHCbSystem'],
               'directories': ['scripts',
                               'DIRAC',
                               'cmt',
                               'DiracSys',
                               'DiracConfig',
                               'DiracHome',
                               'WorkflowLib',
                               'LHCbSystem']
             },
             { 'name': 'DIRAC-external-client',
               'packages': ['contrib/pyGSI',
                            'external/openssl-0.9.7m',
                            'external/sqlite-3.5.4',
                            'external/Python-2.4.4',
                            'external/Python-2.5.2',
                            'external/runit'],
               'directories': ['contrib',
                               'external']
             },
             { 'name' : 'DIRAC-external',
               'packages': ['external/mod_python',
                            'external/classads-0.9.9',
                            'external/MySQL',
                            'external/MySQL-python',
                            'external/rrdtool',
                            'contrib/pyPlotTools',
                            'contrib/ClassAdCondor',
                            'external/Pylons',
                            'external/ldap'],
               'directories': ['contrib',
                               'external']
             },
           ]

workflowLib_tars = [ { 'name': 'WorkflowLib',
                       'packages': ['WorkflowLib'],
                       'directories': ['WorkflowLib']
                     },
                     { 'name': 'LHCbSystem',
                       'packages': ['LHCbSystem'],
                       'directories': ['LHCbSystem']
                     },
                     {}  # Empty dictionary
                   ]


bin_tars = [ { 'name': 'DIRAC-external-client',
               'packages': ['external/sqlite-3.5.4',
                            'contrib/pyGSI']
             },
             { 'name' : 'DIRAC-external',
               'packages': ['contrib/pyPlotTools',
                            'contrib/ClassAdCondor',
                            'external/MySQL',
                            'external/MySQL-python',
                            'external/Pylons',
                            'external/ldap',
                            'external/rrdtool',
                            'external/runit']
             },
           ]

srcNo = len(src_tars)
binNo = len(bin_tars)

# Current python versions in use

python = {'python24':'external/Python-2.4.4',
          'python25':'external/Python-2.5.2' }

siteName = None
ceName   = None
uploadFlag = False

def parse_options_install():
  """
   parse command line options:
  """
  global siteName, ceName, uploadFlag
  help = """
   -b --build                  Force local compilation
   -d --debug                  Set debug flag
   -e --external=<version>     DIRAC-external <version> to install (overwrites -v)
   -h --help                   Print this
   -i --python=<24|25>         Use python<24|25> interpreter
   -n --name=<Site>            Set <Site> as Site Name
   -p --platform=<platform>    Use <platform> instead of local one
   -r --repository=<rep>       Use <rep> as cvs repository
   -u --url=<url>              Use <url> to download tarballs
   -v --version=<version>      DIRAC <version> to install
   -C --cvs                    Retrieve from CVS (implies -b)
   -N --Name=<CEName>          Use <CEName> to determine Site Name
   -P --path=<root>            Install under <root>
   -S --server                 Make a full server installation
   -U --Upload                 Upload compiled distribution to lhcbweb (if -b)

  from DIRAC framework:

    -o --option=<Option=value> <Option=value> to add
    -s --section=<section>     Set base <section> for relative parsed options
    -c --cert=<cert>           Use server certificate <cert> to connect to Core Services

  """
  shortOptions = 'bde:hi:n:p:r:u:v:o:s:CN:P:SU'
  longOptions  = ['build', 'debug', 'external=', 'help', 'python=', 'name',
                  'platform=', 'repository=', 'url=', 'version=',
                  'cvs', 'Name=', 'path=', 'server', 'Upload',
                  'option=', 'section=', 'cert=']
  try:
    ( optionVals, extraOptions ) = getopt.getopt( sys.argv[1:], shortOptions, longOptions )
  except getopt.GetoptError, x:
    dirac.logERROR( 'Parsing command line: %s' % x )
    optionVals = [ ('-h','') ]

  if ('-h','') in optionVals or ('--help','') in optionVals:
    dirac.logHelp( help )

  ext = None

  for o,v in optionVals:
    if o == '-b' or o == '--build':
      dirac.build()
    elif o == '-d' or o == '--debug':
      dirac.debug()
    elif o == '-e' or o == '--external':
      ext = v
    elif o == '-i' or o == '--python':
      dirac.setPython(v)
    elif o == '-n' or o == '--name':
      siteName = v
    elif o == '-p' or o == '--platform':
      dirac.platform(v)
    elif o == '-r' or o == '--repository':
      dirac.setCVS(v)
    elif o == '-u' or o == '--url':
      dirac.setURL( v )
    elif o == '-v' or o == '--version':
      dirac.setVersion(v)
    elif o == '-C' or o == '--cvs':
      dirac.cvsFlag()
      dirac.build()
    elif o == '-N' or o == '--Name':
      ceName = v
    elif o in ('-P', '--path'):
      dirac.setRoot( os.path.join( v, 'scripts', myShortName ) )
    elif o == '-S' or o == '--server':
      dirac.requireServer()
    elif o == '-U' or o == '--Upload':
      uploadFlag = True

    if ext: dirac.setExternal(ext)

def parse_options_distro():
  """
   parse command line options:
  """
  import getopt
  help = """
   -b --build                  Prepare compile tars for local platform
   -d --debug                  Set debug flag
   -e --external=<version>     DIRAC-external <version> to install (overwrites -v)
   -h --help                   Print this
   -i --python=<24|25>         Use python<24|25>
   -r --repository=<rep>       Use <rep> as cvs repository
   -t --tar                    Retrieve from tar
   -u --url=<url>              Use <url> to download tarballs
   -v --version=<version>      DIRAC <version> to install
   -S --server                 Prepare full external tar
   -W --WorkflowLib=<version>  Build just WorkflowLib tar for <version>

  from DIRAC framework:

    -o --option=<Option=value> <Option=value> to add
    -s --section=<section>     Set base <section> for relative parsed options
    -c --cert=<cert>           Use server certificate <cert> to connect to Core Services

  """
  shortOptions = 'bde:hi:p:r:tu:v:o:s:SW:'
  longOptions  = ['build', 'debug', 'external=', 'help', 'python=', 'repository=', 'url=', 'version=',
                  'server', 'tar', 'WorkflowLib=',
                  'option=', 'section=']
  try:
    ( optionVals, extraOptions ) = getopt.getopt( sys.argv[1:], shortOptions, longOptions )
  except getopt.GetoptError, x:
    dirac.logERROR( 'Parsing command line: %s' % x )
    optionVals = [ ('-h','') ]

  if ('-h','') in optionVals or ('--help','') in optionVals:
    dirac.logHelp( help )

  ext = None
  workflowLibVersion = ''
  for o,v in optionVals:
    if o == '-b' or o == '--build':
      dirac.build()
    elif o == '-d' or o == '--debug':
      dirac.debug()
    elif o == '-e' or o == '--external':
      ext = v
    elif o == '-i' or o == '--python':
      dirac.setPython(v)
    elif o == '-r' or o == '--repository':
      dirac.setCVS(v)
    elif o == '-u' or o == '--url':
      dirac.setURL(v)
    elif o == '-v' or o == '--version':
      dirac.setVersion(v)
    elif o == '-t' or o == '--tar':
      dirac.tarFlag()
    elif o == '-S' or o == '--server':
      dirac.requireServer()
    elif o == '-W' or o == '--WorkflowLib':
      workflowLibVersion = v

    if ext: function.External(ext)
    if workflowLibVersion: dirac.workflowLib(workflowLibVersion)


diracTimeout       = 120
externalTimeout    = 300

class Dirac:
  def __init__( self, fullName  ):
    """
     Initialize the functions class using the given script path to set the
     rootPath of the DIRAC intallation.
    """
    self.setRoot( fullName )

    self.debugFlag   = False
    self.buildFlag   = False
    self.CVS         = DIRAC_CVS_REPOSITORY
    self.URL         = DIRAC_HTTP_SERVER
    self.setVersion( DIRAC_VERSION )
    self.setPython( DIRAC_PYTHON )

    self.tarFlag()
    self.requireClient()

    self.localPlatform = None
    # self.platform( )

  def tmpDir(self):
    """
     Create a TMP Directory to to prepare the distribution
    """
    try:
      self.__rootPath = tempfile.mkdtemp( 'tmp', 'DIRAC3')
    except:
      self.__rootPath = tempfile.mktemp()
      os.mkdir( self.__rootPath )

    os.chdir( self.__rootPath )
    self.scriptsPath = os.path.join( self.__rootPath, 'scripts' )
    self.cleanScripts()
    return self.__rootPath

  def __log( self, level, msg ):
    """
     Print log entries similar to DIRAC Logger
    """
    logTime = time.strftime('%Y-%m-%d %H:%M:%S',time.gmtime()) + " UTC"
    # logTime = str( datetime.datetime.utcnow( ) ).split('.')[0] + " UTC"
    if level != 'DEBUG ' or self.debugFlag:
      for line in msg.split( '\n' ):
        print logTime, self.shortName, level, line
        sys.stdout.flush()

  def logEXCEP( self, msg ):
    self.__log( 'EXCEPT', str(msg) )
    sys.exit( -1 )

  def logERROR( self, msg ):
    self.__log( 'ERROR ', msg )

  def logINFO( self, msg ):
    self.__log( 'INFO  ', msg )

  def logDEBUG( self, msg ):
    self.__log( 'DEBUG ', msg )

  def logHelp( self, help ):
    print
    print 'Usage: %s [options]' % self.shortName
    print help
    sys.exit(-1)
    
  def __rmDir(self, dir):
    """
     Remove dir if it exits
    """
    self.logDEBUG( "Removing directory: %s" %  os.path.join( self.__rootPath, dir ))
    if os.path.exists( dir ):
      try:
        shutil.rmtree( dir )
      except Exception, x:
        self.logERROR( 'Can not removed existing directory %s'
                  % os.path.join( self.__rootPath, dir ) )
        self.logEXCEP( x )

  def setRoot( self, fullName ):
    if fullName[0] != '/':
      self.logERROR( 'Install path must be absolute.' )
      sys.exit(-1)
    self.shortName   = os.path.basename( fullName )
    self.scriptsPath = os.path.dirname( fullName )
    if os.path.basename( self.scriptsPath ) != 'scripts':
      # We are doing a new installation, add scripts to PATH
       self.scriptsPath = os.path.join( self.scriptsPath, 'scripts' )

    self.__rootPath    = os.path.dirname( self.scriptsPath )
    try:
      os.chdir( self.__rootPath )
    except Exception, x:
      self.logERROR( 'Can not chdir to requested installation Root "%s"' % self.__rootPath )
      self.logEXCEP( x )

  def root(self):
    return self.__rootPath

  def debug(self):
    """
     Set debug Flag
    """
    self.debugFlag = True
    return self.debugFlag

  def build(self):
    """
     Require local build
    """
    self.buildFlag = True

  def tarFlag(self):
    """
     Require download from tar
    """
    self.fromTar = True
    self.fromCVS = False

  def cvsFlag(self):
    """
     Require download from CVS
    """
    self.fromTar = False
    self.fromCVS = True

  def setURL( self, url ):
    self.URL = url

  def setCVS( self, cvs  ):
    self.CVS = cvs

  def setVersion( self, ver ):
    """
     Set DIRAC version to install, and correponding binary version by setting the minor version to 0.
    """
    self.version  = ver
    extVer = ver
    if re.compile( '^v[0-9]+r[0-9]+p[0-9]+$' ).match( ver ) or re.compile( '^v[0-9]+r[0-9]+$' ).match( ver ):
      extVer = ver[0:re.compile('r[0-9]+').search( ver ).start()]+'r0'
    self.external = extVer

  def setPython( self, ver ):
    self.python = 'python%s' % ver
    if not python.has_key( self.python ):
      self.logERROR( 'Python version "%s" not available' % self.python )
      sys.exit(-1)

  def lhcbPlatform(self):
    """
      determine local architecture as defined by LHCb
    """
    self.lhcb_platform = self.scriptOutput( 'dirac-architecture' )

  def requireServer(self):
    """
     Require full external
    """
    self.serverFlag = True

  def requireClient(self):
    """
     Require full external
    """
    self.serverFlag = False

  def platform( self, platform=None ):
    """
     Use platform.py script to retrieve the local platform
    """
    # First check that we are in a valid directory and create platform.py in the scripts directory
    self.createPlatform()
    self.nativePlatform = self.scriptOutput( 'platform.py' )
    self.localPython = os.path.join( self.__rootPath,
                          self.nativePlatform,
                          'bin', 'python' )
    if not platform:
      self.localPlatform = self.nativePlatform
    else:
      if platform in platformDict:
        self.localPlatform = platformDict[platform]
      else:
        self.localPlatform = platform

    if self.localPlatform == 'ERROR' or self.localPlatform == "":
      self.logERROR( 'Can not determine local platform' )
      sys.exit(-1)

    self.installedPython = os.path.join( self.__rootPath,
                           self.localPlatform,
                           'bin', 'python' )

  def createSrcTars(self):
    """
     Create distribution tars for source code
    """
    tars = 0
    n = srcNo
    if not self.serverFlag:
      # prepare tars only for a client distribution
      n -= 1
    if self.fromCVS:
      for i in range(n):
        tar = src_tars[i]
        name = tar['name']
        version = self.version
        if name.find('external') != -1 :
          version = self.external
        self._getCVS( version, tar['packages']  )
        tarName = '%s-%s' % ( name, version )
        if name == 'DIRAC':
          self._diracMake( 'DIRAC' )
        self._createTar( tarName, tar['directories'] )
        tars += 1
    else:
      self.logINFO( 'Donwloading from tar, do not create src tars.' )
      if self.buildFlag:
        # if build is required, download external tars
        for i in range(n):
          name = src_tars[i]['name']
          if i == 0 or name.find('external') != -1 :
            tarName = '%s-%s' % ( name, self.external )
            self._getTar( tarName, externalTimeout )
    return tars

  def createBinTars(self):
    """
     Create distribution tars with compiled components
    """
    tars = 0
    if not self.buildFlag:
      return tars
    n = binNo
    tarDirs = [self.localPlatform]
    if not self.serverFlag:
      # prepare tars only for a client distribution
      n -= 1
    for i in range(n):
      tar = bin_tars[i]
      name = tar['name']
      for j in range(len(tar['packages'])):
        dir = tar['packages'][j]
        self._diracMake( dir )
        if i == 0 and j == 0:
          self._diracMake( python[self.python] )
          # need to check zlib module
          # try:
          #   import zlib
          # except Exception, x:
          #   self.logEXCEP( x )
          
      tarName = '%s-%s-%s-%s' % ( name, self.external, self.localPlatform, self.python )
      if i == binNo - 1:
        tarDirs.append('mysql')
      self._createTar( tarName, tarDirs )
      tars += 1
    return tars

  def checkDirac(self):
    """
     Compare required DIRAC version with installed one and update if necesary
    """
    localVersion = self.checkDiracVersion()
    if self.version == localVersion:
      self.logDEBUG( 'DIRAC version "%s" already installed' % self.version )
    else:
      if os.path.exists( 'DIRAC' ):
        self.__rmDir( 'DIRAC.old' )
        shutil.copytree( 'DIRAC', 'DIRAC.old' )
        shutil.rmtree( 'DIRAC' )
      if self.fromTar:
        name = 'DIRAC-%s' % self.version
        self._getTar( name, diracTimeout )
      else:
        name = 'DIRAC'
        self._getCVS( self.version, [name] )
      # Hack to handle LHCbSystem
      try:
        shutil.copytree( 'LHCbSystem', os.path.join( 'DIRAC', 'LHCbSystem' ) )
        shutil.rmtree( 'LHCbSystem' )
      except:
        pass
      self._diracMake( 'DIRAC' )
      # self._diracMagic( )
      # to be fixed
      self.version = self.checkDiracVersion()
      if not self.version or self.version.find('ERROR') != -1:
        self.logERROR( 'Can not determine installed DIRAC version' )
        self.logERROR( 'native platform "%s" is not installed' % dirac.nativePlatform )
        self.logERROR( 'and installed platform "%s" is not compatible' % dirac.localPlatform )
        self.__rmDir( 'DIRAC' )
        if os.path.exists( 'DIRAC.old' ):
          shutil.copytree( 'DIRAC.old', 'DIRAC' )
          shutil.rmtree( 'DIRAC.old' )
        sys.exit(-1)
      self.logDEBUG( 'DIRAC version "%s" installed' % self.version )

    return self.version

  def checkDiracVersion(self):
    """
     Check local DIRAC instalation a get version
    """
    self.checkDiracCfg()
    if os.path.exists( self.localPython ):
      localVersion = self.scriptOutput( 'dirac-version', False, self.localPython )
    else:
      localVersion = self.scriptOutput( 'dirac-version', False, self.installedPython )

    if localVersion:
      self.logDEBUG( 'Currently installed DIRAC version is %s' % localVersion )
    return localVersion

  def checkDiracCfg(self):
    """
     Make sure that dirac.cfg file exists in the default location, even if empty
    """
    etcPath = os.path.join( self.__rootPath, 'etc')
    cfgPath = os.path.join( etcPath, 'dirac.cfg' )
    if not os.path.exists( etcPath ):
      try:
        os.mkdir( etcPath )
      except Exception, x :
        self.logERROR( 'Can not create "%s", check permissions' % etcPath )
        self.logEXCEP( x )

    if not os.path.exists( cfgPath ):
      try:
        file = open( cfgPath, 'w' )
      except Exception, x :
        self.logERROR( 'Can not create "%s", check permissions' % cfgPath)
        self.logEXCEP( x )
    elif not os.access( cfgPath, os.R_OK ):
      try:
        file =  open( cfgPath, 'r' )
      except Exception, x :
        self.logERROR( 'Can not read "%s", check permissions' % cfgPath )
        self.logEXCEP( x )

    return cfgPath

  def _diracMake( self, dir ):
    """
     Build packages using dirac-make script, on the given directory
    """
    self.logINFO( ' Building "%s"' % dir )
    diracMake = os.path.join( dir, 'dirac-make' )
    makeCmd = '%s 1>> %s.log 2>> %s.log' % ( diracMake, diracMake, diracMake )
    self.logDEBUG( makeCmd )
    ret = os.system ( makeCmd )
    if ret != 0:
      self.logERROR( 'Failed making %s' %dir )
      self.logERROR( 'Check log file at "%s.log"' % diracMake )
      f = open( '%s.log' % diracMake )
      lines = f.readlines()
      while lines:
        self.logERROR( str.join('',lines) )
        lines = f.readlines()
      sys.exit( -1 )

  def _getCVS( self, version, packages ):
    """
     Check access to CVS repository (retrieve scripts)
    """
    cvsPackages = []

    for destDir in packages:
      # remove existing directories, if any
      cvsDir = 'DIRAC3/%s' % destDir
      cvsPackages.append(cvsDir)

      self.__rmDir( cvsDir )
      self.__rmDir( destDir )

    self.logINFO( 'Retrieving %s' % ', '.join(cvsPackages) )
    cvsCmd = 'cvs -Q -d %s export -f -r %s %s' \
             % ( self.CVS, version, ' '.join(cvsPackages) )
    if self.debugFlag:
      cvsCmd = 'cvs -q -d %s export -f -r %s %s' \
               % ( self.CVS, version, ' '.join(cvsPackages) )
    self.logDEBUG( cvsCmd )
    ret = os.system( cvsCmd )
    if ret != 0:
      self.logEXCEP( 'Check your cvs installation' )
    # Move the resulting dirs
    for destDir in packages:
      cvsDir = 'DIRAC3/%s' % destDir
      try:
        os.renames( cvsDir, destDir )
      except Exception, x:
        self.logERROR( 'Failed to rename "%s" to "%s"' % (cvsDir, destDir ) )
        self.logEXCEP(x)

  def _getTar( self, name, timeout, dir=None, reportError=True ):

    try:
      ( file, localName ) = tempfile.mkstemp()
    except:
      localName = tempfile.mktemp()
    tarFileName = os.path.join( '%s.tar.gz' % name )
    remoteName = '%s/%s' % ( self.URL, tarFileName )
    error = 'Retrieving file "%s"' % remoteName
    try:
      self.urlretrieveTimeout( remoteName, localName, timeout )
      error = 'Openning file "%s"' % localName
      # import tarfile
      tar = tarfile.open( localName , 'r' )
      try:
        error = 'Extracting file "%s"' % localName
        self.__rmDir( dir )
        tar.extractall( )
        os.remove( localName )
      except:
        for member in tar.getmembers():
          tar.extract( member )
        os.remove( localName )

    except Exception, x:
      try:
        error = 'Extracting file "%s"' % localName
        ret = os.system( 'tar -tzf %s > /dev/null' % localName )
        if ret != 0:
          raise Exception( 'Fail to extract tarfile'  )
        if dir:
          self.__rmDir( dir )
        ret = os.system( 'tar xzf %s' % localName )
        if ret != 0:
          raise Exception( 'Fail to extract tarfile'  )
        os.remove( localName )
        return
      except Exception, x:
        pass
      if reportError:
        self.logERROR( error )
        self.logEXCEP( x )

  def _createTar( self, name, dirs):
    """
     Create distribution tar from given directory list
    """
    tarFileName = '%s.tar.gz' % name
    self.logINFO( '  Creating tar file %s'  % tarFileName )
    self.logDEBUG( '   including directories: %s' % str.join( ', ', dirs ) )
    try:
      # import tarfile
      tarFile = tarfile.open( tarFileName, 'w:gz' )
      for dir in dirs:
        self.cleanDir( dir )
        tarFile.add( dir )
      tarFile.close()
    except Exception, x:
      ret = os.system( 'tar czf %s %s' % (tarFileName, str.join(' ',dirs) ) )
      if ret == 0: return
      self.logERROR( 'Failed to create tar' )
      self.logEXCEP( x )

  def urlretrieveTimeout( self, fname, lname, timeout ):
    """
     Retrive remore url to local file, with timeout wrapper
    """
    # NOTE: Not thread-safe, since all threads will catch same alarm.
    #       This is OK for dirac-install, since there are no threads.
    self.logDEBUG( 'Retrieving remote file "%s"' % fname )

    signal.signal(signal.SIGALRM, self.alarmHandler)
    # set timeout alarm
    signal.alarm(timeout)
    try:
      localname,headers = urllib.urlretrieve( fname, lname )
    except Exception, x:
      if x == 'TimeOut':
        self.logERROR( 'Timeout after %s seconds on transfer request for "%s"' % \
        (str(timeout), fname) )
      # clear timeout alarm
      signal.alarm(0)
      raise x

    # clear timeout alarm
    signal.alarm(0)

  def buildExternal( self ):
    """
     Build external packages for local platform
    """
    n = srcNo
    if not self.serverFlag:
      n -= 1
    if self.fromTar:
      self.logINFO( 'Donwloading src tar' )
      for i in range(n):
        tar = src_tars[i]
        name = tar['name']
        if i == 0 or name.find('external') != -1 :
          tarName = '%s-%s' % ( name, self.external )
          self._getTar( tarName, externalTimeout )
    else:
      self.logINFO( 'Donwloading src from CVS' )
      for i in range(n):
        tar = src_tars[i]
        name = tar['name']
        version = self.version
        if name.find('external') != -1 :
          version = self.external
          self._getCVS( version, tar['packages']  )

    n = binNo
    if not self.serverFlag:
      n -= 1
    for i in range(n):
      tar = bin_tars[i]
      name = tar['name']
      for j in range(len(tar['packages'])):
        dir = tar['packages'][j]
        self._diracMake( dir )
        if i == 0 and j == 0:
          self._diracMake( python[self.python] )

  def checkInterpreter( self ):
    """
     Check if DIRAC version of python interpreter is installed and make sure
     all scripts will make use of it
    """
    python = sys.executable
    if os.path.realpath(python) ==  os.path.realpath(self.localPython):
      self.logDEBUG( 'Using python interpreter "%s"' % python )
      return True
    if os.path.realpath(python) ==  os.path.realpath(self.installedPython):
      self.logDEBUG( 'Using python interpreter "%s"' % python )
      return True
    else:
      return False
    
  def installExternal( self ):
    """
     Install external package for the requiered platform
    """
    # remove requested platform directory if it exists
    externalDir = os.path.join( self.__rootPath, self.localPlatform )

    if self.buildFlag:
      self.__rmDir( externalDir )
      self.buildExternal( )
    else:
      if not self.localPlatform in availablePlatforms:
        self.logERROR( 'Platform "%s" not available, use --build flag' %
                  self.localPlatform )
        sys.exit(1)
      if self.serverFlag:
        name = 'DIRAC-external-%s-%s-%s' % \
        ( self.external, self.localPlatform, self.python )
      else:
        name = 'DIRAC-external-client-%s-%s-%s' % \
        ( self.external, self.localPlatform, self.python )
      self._getTar( name, externalTimeout, externalDir )

    name = 'DIRAC-lcg-%s-%s-%s' % ( lcgVer, self.localPlatform, self.python )
    try:
      self._getTar( name, externalTimeout, reportError=False )
    except:
      self.logINFO( 'LCG tool tar file is not available for your platform' )


  def cleanScripts(self):
    """
     Remove any entries in the scripts directory
    """
    self.__rmDir( self.scriptsPath )
    try:
      os.mkdir( self.scriptsPath )
    except Exception, x :
      self.logERROR( 'Can not create "%s", check permissions' % self.scriptsPath )
      self.logEXCEP( x )
  def createPlatform(self):
    """
     Create platform.py in scripts directory
    """
    platformFile = os.path.join( self.scriptsPath, 'platform.py' )
    try:
      f = open(platformFile,'w')
      f.write("""#!/usr/bin/env python

\"\"\" This module tries to retrieve as much platform-identifying data as
    possible. It makes this information available via function APIs.

    If called from the command line, it prints the platform
    information concatenated as single string to stdout. The output
    format is useable as part of a filename.

\"\"\"
#    This module is maintained by Marc-Andre Lemburg <mal@egenix.com>.
#    If you find problems, please submit bug reports/patches via the
#    Python SourceForge Project Page and assign them to "lemburg".
#
#    Note: Please keep this module compatible to Python 1.5.2.
#
#    Still needed:
#    * more support for WinCE
#    * support for MS-DOS (PythonDX ?)
#    * support for Amiga and other still unsupported platforms running Python
#    * support for additional Linux distributions
#
#    Many thanks to all those who helped adding platform-specific
#    checks (in no particular order):
#
#      Charles G Waldman, David Arnold, Gordon McMillan, Ben Darnell,
#      Jeff Bauer, Cliff Crawford, Ivan Van Laningham, Josef
#      Betancourt, Randall Hopper, Karl Putland, John Farrell, Greg
#      Andruk, Just van Rossum, Thomas Heller, Mark R. Levinson, Mark
#      Hammond, Bill Tutt, Hans Nowak, Uwe Zessin (OpenVMS support),
#      Colin Kong, Trent Mick, Guido van Rossum
#
#    History:
#
#    <see CVS and SVN checkin messages for history>
#
#    1.0.3 - added normalization of Windows system name
#    1.0.2 - added more Windows support
#    1.0.1 - reformatted to make doc.py happy
#    1.0.0 - reformatted a bit and checked into Python CVS
#    0.8.0 - added sys.version parser and various new access
#            APIs (python_version(), python_compiler(), etc.)
#    0.7.2 - fixed architecture() to use sizeof(pointer) where available
#    0.7.1 - added support for Caldera OpenLinux
#    0.7.0 - some fixes for WinCE; untabified the source file
#    0.6.2 - support for OpenVMS - requires version 1.5.2-V006 or higher and
#            vms_lib.getsyi() configured
#    0.6.1 - added code to prevent 'uname -p' on platforms which are
#            known not to support it
#    0.6.0 - fixed win32_ver() to hopefully work on Win95,98,NT and Win2k;
#            did some cleanup of the interfaces - some APIs have changed
#    0.5.5 - fixed another type in the MacOS code... should have
#            used more coffee today ;-)
#    0.5.4 - fixed a few typos in the MacOS code
#    0.5.3 - added experimental MacOS support; added better popen()
#            workarounds in _syscmd_ver() -- still not 100% elegant
#            though
#    0.5.2 - fixed uname() to return '' instead of 'unknown' in all
#            return values (the system uname command tends to return
#            'unknown' instead of just leaving the field emtpy)
#    0.5.1 - included code for slackware dist; added exception handlers
#            to cover up situations where platforms don't have os.popen
#            (e.g. Mac) or fail on socket.gethostname(); fixed libc
#            detection RE
#    0.5.0 - changed the API names referring to system commands to *syscmd*;
#            added java_ver(); made syscmd_ver() a private
#            API (was system_ver() in previous versions) -- use uname()
#            instead; extended the win32_ver() to also return processor
#            type information
#    0.4.0 - added win32_ver() and modified the platform() output for WinXX
#    0.3.4 - fixed a bug in _follow_symlinks()
#    0.3.3 - fixed popen() and "file" command invokation bugs
#    0.3.2 - added architecture() API and support for it in platform()
#    0.3.1 - fixed syscmd_ver() RE to support Windows NT
#    0.3.0 - added system alias support
#    0.2.3 - removed 'wince' again... oh well.
#    0.2.2 - added 'wince' to syscmd_ver() supported platforms
#    0.2.1 - added cache logic and changed the platform string format
#    0.2.0 - changed the API to use functions instead of module globals
#            since some action take too long to be run on module import
#    0.1.0 - first release
#
#    You can always get the latest version of this module at:
#
#             http://www.egenix.com/files/python/platform.py
#
#    If that URL should fail, try contacting the author.

__copyright__ = \"\"\"
    Copyright (c) 1999-2000, Marc-Andre Lemburg; mailto:mal@lemburg.com
    Copyright (c) 2000-2003, eGenix.com Software GmbH; mailto:info@egenix.com

    Permission to use, copy, modify, and distribute this software and its
    documentation for any purpose and without fee or royalty is hereby granted,
    provided that the above copyright notice appear in all copies and that
    both that copyright notice and this permission notice appear in
    supporting documentation or portions thereof, including modifications,
    that you make.

    EGENIX.COM SOFTWARE GMBH DISCLAIMS ALL WARRANTIES WITH REGARD TO
    THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
    FITNESS, IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL,
    INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING
    FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
    NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
    WITH THE USE OR PERFORMANCE OF THIS SOFTWARE !

\"\"\"

__version__ = '1.0.4'

import sys,string,os,re

### Platform specific APIs

_libc_search = re.compile(r'(__libc_init)'
                          '|'
                          '(GLIBC_([0-9.]+))'
                          '|'
                          '(libc(_\\w+)?\\.so(?:\\.(\\d[0-9.]*))?)')

def libc_ver(executable=sys.executable,lib='',version='',

             chunksize=2048):

    \"\"\" Tries to determine the libc version that the file executable
        (which defaults to the Python interpreter) is linked against.

        Returns a tuple of strings (lib,version) which default to the
        given parameters in case the lookup fails.

        Note that the function has intimate knowledge of how different
        libc versions add symbols to the executable and thus is probably
        only useable for executables compiled using gcc.

        The file is read and scanned in chunks of chunksize bytes.

    \"\"\"
    f = open(executable,'rb')
    binary = f.read(chunksize)
    pos = 0
    while 1:
        m = _libc_search.search(binary,pos)
        if not m:
            binary = f.read(chunksize)
            if not binary:
                break
            pos = 0
            continue
        libcinit,glibc,glibcversion,so,threads,soversion = m.groups()
        if libcinit and not lib:
            lib = 'libc'
        elif glibc:
            if lib != 'glibc':
                lib = 'glibc'
                version = glibcversion
            elif glibcversion > version:
                version = glibcversion
        elif so:
            if lib != 'glibc':
                lib = 'libc'
                if soversion > version:
                    version = soversion
                if threads and version[-len(threads):] != threads:
                    version = version + threads
        pos = m.end()
    f.close()
    return lib,version

def _dist_try_harder(distname,version,id):

    \"\"\" Tries some special tricks to get the distribution
        information in case the default method fails.

        Currently supports older SuSE Linux, Caldera OpenLinux and
        Slackware Linux distributions.

    \"\"\"
    if os.path.exists('/var/adm/inst-log/info'):
        # SuSE Linux stores distribution information in that file
        info = open('/var/adm/inst-log/info').readlines()
        distname = 'SuSE'
        for line in info:
            tv = string.split(line)
            if len(tv) == 2:
                tag,value = tv
            else:
                continue
            if tag == 'MIN_DIST_VERSION':
                version = string.strip(value)
            elif tag == 'DIST_IDENT':
                values = string.split(value,'-')
                id = values[2]
        return distname,version,id

    if os.path.exists('/etc/.installed'):
        # Caldera OpenLinux has some infos in that file (thanks to Colin Kong)
        info = open('/etc/.installed').readlines()
        for line in info:
            pkg = string.split(line,'-')
            if len(pkg) >= 2 and pkg[0] == 'OpenLinux':
                # XXX does Caldera support non Intel platforms ? If yes,
                #     where can we find the needed id ?
                return 'OpenLinux',pkg[1],id

    if os.path.isdir('/usr/lib/setup'):
        # Check for slackware verson tag file (thanks to Greg Andruk)
        verfiles = os.listdir('/usr/lib/setup')
        for n in range(len(verfiles)-1, -1, -1):
            if verfiles[n][:14] != 'slack-version-':
                del verfiles[n]
        if verfiles:
            verfiles.sort()
            distname = 'slackware'
            version = verfiles[-1][14:]
            return distname,version,id

    return distname,version,id

_release_filename = re.compile(r'(\\w+)[-_](release|version)')
_release_version = re.compile(r'([\\d.]+)[^(]*(?:\\((.+)\\))?')

# Note:In supported_dists below we need 'fedora' before 'redhat' as in
# Fedora redhat-release is a link to fedora-release.

def dist(distname='',version='',id='',

         supported_dists=('SuSE', 'debian', 'fedora', 'redhat', 'mandrake')):

    \"\"\" Tries to determine the name of the Linux OS distribution name.

        The function first looks for a distribution release file in
        /etc and then reverts to _dist_try_harder() in case no
        suitable files are found.

        Returns a tuple (distname,version,id) which default to the
        args given as parameters.

    \"\"\"
    try:
        etc = os.listdir('/etc')
    except os.error:
        # Probably not a Unix system
        return distname,version,id
    for file in etc:
        m = _release_filename.match(file)
        if m:
            _distname,dummy = m.groups()
            if _distname in supported_dists:
                distname = _distname
                break
    else:
        return _dist_try_harder(distname,version,id)
    f = open('/etc/'+file,'r')
    firstline = f.readline()
    f.close()
    m = _release_version.search(firstline)
    if m:
        _version,_id = m.groups()
        if _version:
            version = _version
        if _id:
            id = _id
    else:
        # Unkown format... take the first two words
        l = string.split(string.strip(firstline))
        if l:
            version = l[0]
            if len(l) > 1:
                id = l[1]
    return distname,version,id

class _popen:

    \"\"\" Fairly portable (alternative) popen implementation.

        This is mostly needed in case os.popen() is not available, or
        doesn't work as advertised, e.g. in Win9X GUI programs like
        PythonWin or IDLE.

        Writing to the pipe is currently not supported.

    \"\"\"
    tmpfile = ''
    pipe = None
    bufsize = None
    mode = 'r'

    def __init__(self,cmd,mode='r',bufsize=None):

        if mode != 'r':
            raise ValueError,'popen()-emulation only supports read mode'
        import tempfile
        self.tmpfile = tmpfile = tempfile.mktemp()
        os.system(cmd + ' > %s' % tmpfile)
        self.pipe = open(tmpfile,'rb')
        self.bufsize = bufsize
        self.mode = mode

    def read(self):

        return self.pipe.read()

    def readlines(self):

        if self.bufsize is not None:
            return self.pipe.readlines()

    def close(self,

              remove=os.unlink,error=os.error):

        if self.pipe:
            rc = self.pipe.close()
        else:
            rc = 255
        if self.tmpfile:
            try:
                remove(self.tmpfile)
            except error:
                pass
        return rc

    # Alias
    __del__ = close

def popen(cmd, mode='r', bufsize=None):

    \"\"\" Portable popen() interface.
    \"\"\"
    # Find a working popen implementation preferring win32pipe.popen
    # over os.popen over _popen
    popen = None
    if os.environ.get('OS','') == 'Windows_NT':
        # On NT win32pipe should work; on Win9x it hangs due to bugs
        # in the MS C lib (see MS KnowledgeBase article Q150956)
        try:
            import win32pipe
        except ImportError:
            pass
        else:
            popen = win32pipe.popen
    if popen is None:
        if hasattr(os,'popen'):
            popen = os.popen
            # Check whether it works... it doesn't in GUI programs
            # on Windows platforms
            if sys.platform == 'win32': # XXX Others too ?
                try:
                    popen('')
                except os.error:
                    popen = _popen
        else:
            popen = _popen
    if bufsize is None:
        return popen(cmd,mode)
    else:
        return popen(cmd,mode,bufsize)

def _norm_version(version,build=''):

    \"\"\" Normalize the version and build strings and return a single
        version string using the format major.minor.build (or patchlevel).
    \"\"\"
    l = string.split(version,'.')
    if build:
        l.append(build)
    try:
        ints = map(int,l)
    except ValueError:
        strings = l
    else:
        strings = map(str,ints)
    version = string.join(strings[:3],'.')
    return version

_ver_output = re.compile(r'(?:([\\w ]+) ([\\w.]+) '
                         '.*'
                         'Version ([\\d.]+))')

def _syscmd_ver(system='',release='',version='',

               supported_platforms=('win32','win16','dos','os2')):

    \"\"\" Tries to figure out the OS version used and returns
        a tuple (system,release,version).

        It uses the "ver" shell command for this which is known
        to exists on Windows, DOS and OS/2. XXX Others too ?

        In case this fails, the given parameters are used as
        defaults.

    \"\"\"
    if sys.platform not in supported_platforms:
        return system,release,version

    # Try some common cmd strings
    for cmd in ('ver','command /c ver','cmd /c ver'):
        try:
            pipe = popen(cmd)
            info = pipe.read()
            if pipe.close():
                raise os.error,'command failed'
            # XXX How can I supress shell errors from being written
            #     to stderr ?
        except os.error,why:
            #print 'Command %s failed: %s' % (cmd,why)
            continue
        except IOError,why:
            #print 'Command %s failed: %s' % (cmd,why)
            continue
        else:
            break
    else:
        return system,release,version

    # Parse the output
    info = string.strip(info)
    m = _ver_output.match(info)
    if m:
        system,release,version = m.groups()
        # Strip trailing dots from version and release
        if release[-1] == '.':
            release = release[:-1]
        if version[-1] == '.':
            version = version[:-1]
        # Normalize the version and build strings (eliminating additional
        # zeros)
        version = _norm_version(version)
    return system,release,version

def _win32_getvalue(key,name,default=''):

    \"\"\" Read a value for name from the registry key.

        In case this fails, default is returned.

    \"\"\"
    from win32api import RegQueryValueEx
    try:
        return RegQueryValueEx(key,name)
    except:
        return default

def win32_ver(release='',version='',csd='',ptype=''):

    \"\"\" Get additional version information from the Windows Registry
        and return a tuple (version,csd,ptype) referring to version
        number, CSD level and OS type (multi/single
        processor).

        As a hint: ptype returns 'Uniprocessor Free' on single
        processor NT machines and 'Multiprocessor Free' on multi
        processor machines. The 'Free' refers to the OS version being
        free of debugging code. It could also state 'Checked' which
        means the OS version uses debugging code, i.e. code that
        checks arguments, ranges, etc. (Thomas Heller).

        Note: this function only works if Mark Hammond's win32
        package is installed and obviously only runs on Win32
        compatible platforms.

    \"\"\"
    # XXX Is there any way to find out the processor type on WinXX ?
    # XXX Is win32 available on Windows CE ?
    #
    # Adapted from code posted by Karl Putland to comp.lang.python.
    #
    # The mappings between reg. values and release names can be found
    # here: http://msdn.microsoft.com/library/en-us/sysinfo/base/osversioninfo_str.asp

    # Import the needed APIs
    try:
        import win32api
    except ImportError:
        return release,version,csd,ptype
    from win32api import RegQueryValueEx,RegOpenKeyEx,RegCloseKey,GetVersionEx
    from win32con import HKEY_LOCAL_MACHINE,VER_PLATFORM_WIN32_NT,\\
                         VER_PLATFORM_WIN32_WINDOWS

    # Find out the registry key and some general version infos
    maj,min,buildno,plat,csd = GetVersionEx()
    version = '%i.%i.%i' % (maj,min,buildno & 0xFFFF)
    if csd[:13] == 'Service Pack ':
        csd = 'SP' + csd[13:]
    if plat == VER_PLATFORM_WIN32_WINDOWS:
        regkey = 'SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion'
        # Try to guess the release name
        if maj == 4:
            if min == 0:
                release = '95'
            elif min == 10:
                release = '98'
            elif min == 90:
                release = 'Me'
            else:
                release = 'postMe'
        elif maj == 5:
            release = '2000'
    elif plat == VER_PLATFORM_WIN32_NT:
        regkey = 'SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion'
        if maj <= 4:
            release = 'NT'
        elif maj == 5:
            if min == 0:
                release = '2000'
            elif min == 1:
                release = 'XP'
            elif min == 2:
                release = '2003Server'
            else:
                release = 'post2003'
    else:
        if not release:
            # E.g. Win3.1 with win32s
            release = '%i.%i' % (maj,min)
        return release,version,csd,ptype

    # Open the registry key
    try:
        keyCurVer = RegOpenKeyEx(HKEY_LOCAL_MACHINE,regkey)
        # Get a value to make sure the key exists...
        RegQueryValueEx(keyCurVer,'SystemRoot')
    except:
        return release,version,csd,ptype

    # Parse values
    #subversion = _win32_getvalue(keyCurVer,
    #                            'SubVersionNumber',
    #                            ('',1))[0]
    #if subversion:
    #   release = release + subversion # 95a, 95b, etc.
    build = _win32_getvalue(keyCurVer,
                            'CurrentBuildNumber',
                            ('',1))[0]
    ptype = _win32_getvalue(keyCurVer,
                           'CurrentType',
                           (ptype,1))[0]

    # Normalize version
    version = _norm_version(version,build)

    # Close key
    RegCloseKey(keyCurVer)
    return release,version,csd,ptype

def _mac_ver_lookup(selectors,default=None):

    from gestalt import gestalt
    import MacOS
    l = []
    append = l.append
    for selector in selectors:
        try:
            append(gestalt(selector))
        except (RuntimeError, MacOS.Error):
            append(default)
    return l

def _bcd2str(bcd):

    return hex(bcd)[2:]

def mac_ver(release='',versioninfo=('','',''),machine=''):

    \"\"\" Get MacOS version information and return it as tuple (release,
        versioninfo, machine) with versioninfo being a tuple (version,
        dev_stage, non_release_version).

        Entries which cannot be determined are set to the paramter values
        which default to ''. All tuple entries are strings.

        Thanks to Mark R. Levinson for mailing documentation links and
        code examples for this function. Documentation for the
        gestalt() API is available online at:

           http://www.rgaros.nl/gestalt/

    \"\"\"
    # Check whether the version info module is available
    try:
        import gestalt
        import MacOS
    except ImportError:
        return release,versioninfo,machine
    # Get the infos
    sysv,sysu,sysa = _mac_ver_lookup(('sysv','sysu','sysa'))
    # Decode the infos
    if sysv:
        major = (sysv & 0xFF00) >> 8
        minor = (sysv & 0x00F0) >> 4
        patch = (sysv & 0x000F)
        release = '%s.%i.%i' % (_bcd2str(major),minor,patch)
    if sysu:
        major =  int((sysu & 0xFF000000L) >> 24)
        minor =  (sysu & 0x00F00000) >> 20
        bugfix = (sysu & 0x000F0000) >> 16
        stage =  (sysu & 0x0000FF00) >> 8
        nonrel = (sysu & 0x000000FF)
        version = '%s.%i.%i' % (_bcd2str(major),minor,bugfix)
        nonrel = _bcd2str(nonrel)
        stage = {0x20:'development',
                 0x40:'alpha',
                 0x60:'beta',
                 0x80:'final'}.get(stage,'')
        versioninfo = (version,stage,nonrel)
    if sysa:
        machine = {0x1: '68k',
                   0x2: 'PowerPC',
                   0xa: 'i386'}.get(sysa,'')
    return release,versioninfo,machine

def _java_getprop(name,default):

    from java.lang import System
    try:
        return System.getProperty(name)
    except:
        return default

def java_ver(release='',vendor='',vminfo=('','',''),osinfo=('','','')):

    \"\"\" Version interface for Jython.

        Returns a tuple (release,vendor,vminfo,osinfo) with vminfo being
        a tuple (vm_name,vm_release,vm_vendor) and osinfo being a
        tuple (os_name,os_version,os_arch).

        Values which cannot be determined are set to the defaults
        given as parameters (which all default to '').

    \"\"\"
    # Import the needed APIs
    try:
        import java.lang
    except ImportError:
        return release,vendor,vminfo,osinfo

    vendor = _java_getprop('java.vendor',vendor)
    release = _java_getprop('java.version',release)
    vm_name,vm_release,vm_vendor = vminfo
    vm_name = _java_getprop('java.vm.name',vm_name)
    vm_vendor = _java_getprop('java.vm.vendor',vm_vendor)
    vm_release = _java_getprop('java.vm.version',vm_release)
    vminfo = vm_name,vm_release,vm_vendor
    os_name,os_version,os_arch = osinfo
    os_arch = _java_getprop('java.os.arch',os_arch)
    os_name = _java_getprop('java.os.name',os_name)
    os_version = _java_getprop('java.os.version',os_version)
    osinfo = os_name,os_version,os_arch

    return release,vendor,vminfo,osinfo

### System name aliasing

def system_alias(system,release,version):

    \"\"\" Returns (system,release,version) aliased to common
        marketing names used for some systems.

        It also does some reordering of the information in some cases
        where it would otherwise cause confusion.

    \"\"\"
    if system == 'Rhapsody':
        # Apple's BSD derivative
        # XXX How can we determine the marketing release number ?
        return 'MacOS X Server',system+release,version

    elif system == 'SunOS':
        # Sun's OS
        if release < '5':
            # These releases use the old name SunOS
            return system,release,version
        # Modify release (marketing release = SunOS release - 3)
        l = string.split(release,'.')
        if l:
            try:
                major = int(l[0])
            except ValueError:
                pass
            else:
                major = major - 3
                l[0] = str(major)
                release = string.join(l,'.')
        if release < '6':
            system = 'Solaris'
        else:
            # XXX Whatever the new SunOS marketing name is...
            system = 'Solaris'

    elif system == 'IRIX64':
        # IRIX reports IRIX64 on platforms with 64-bit support; yet it
        # is really a version and not a different platform, since 32-bit
        # apps are also supported..
        system = 'IRIX'
        if version:
            version = version + ' (64bit)'
        else:
            version = '64bit'

    elif system in ('win32','win16'):
        # In case one of the other tricks
        system = 'Windows'

    return system,release,version

### Various internal helpers

def _platform(*args):

    \"\"\" Helper to format the platform string in a filename
        compatible format e.g. "system-version-machine".
    \"\"\"
    # Format the platform string
    platform = string.join(
        map(string.strip,
            filter(len,args)),
        '-')

    # Cleanup some possible filename obstacles...
    replace = string.replace
    platform = replace(platform,' ','_')
    platform = replace(platform,'/','-')
    platform = replace(platform,'\\\\','-')
    platform = replace(platform,':','-')
    platform = replace(platform,';','-')
    platform = replace(platform,'"','-')
    platform = replace(platform,'(','-')
    platform = replace(platform,')','-')

    # No need to report 'unknown' information...
    platform = replace(platform,'unknown','')

    # Fold '--'s and remove trailing '-'
    while 1:
        cleaned = replace(platform,'--','-')
        if cleaned == platform:
            break
        platform = cleaned
    while platform[-1] == '-':
        platform = platform[:-1]

    return platform

def _node(default=''):

    \"\"\" Helper to determine the node name of this machine.
    \"\"\"
    try:
        import socket
    except ImportError:
        # No sockets...
        return default
    try:
        return socket.gethostname()
    except socket.error:
        # Still not working...
        return default

# os.path.abspath is new in Python 1.5.2:
if not hasattr(os.path,'abspath'):

    def _abspath(path,

                 isabs=os.path.isabs,join=os.path.join,getcwd=os.getcwd,
                 normpath=os.path.normpath):

        if not isabs(path):
            path = join(getcwd(), path)
        return normpath(path)

else:

    _abspath = os.path.abspath

def _follow_symlinks(filepath):

    \"\"\" In case filepath is a symlink, follow it until a
        real file is reached.
    \"\"\"
    filepath = _abspath(filepath)
    while os.path.islink(filepath):
        filepath = os.path.normpath(
            os.path.join(filepath,os.readlink(filepath)))
    return filepath

def _syscmd_uname(option,default=''):

    \"\"\" Interface to the system's uname command.
    \"\"\"
    if sys.platform in ('dos','win32','win16','os2'):
        # XXX Others too ?
        return default
    try:
        f = os.popen('uname %s 2> /dev/null' % option)
    except (AttributeError,os.error):
        return default
    output = string.strip(f.read())
    rc = f.close()
    if not output or rc:
        return default
    else:
        return output

def _syscmd_file(target,default=''):

    \"\"\" Interface to the system's file command.

        The function uses the -b option of the file command to have it
        ommit the filename in its output and if possible the -L option
        to have the command follow symlinks. It returns default in
        case the command should fail.

    \"\"\"
    target = _follow_symlinks(target)
    try:
        f = os.popen('file %s 2> /dev/null' % target)
    except (AttributeError,os.error):
        return default
    output = string.strip(f.read())
    rc = f.close()
    if not output or rc:
        return default
    else:
        return output

### Information about the used architecture

# Default values for architecture; non-empty strings override the
# defaults given as parameters
_default_architecture = {
    'win32': ('','WindowsPE'),
    'win16': ('','Windows'),
    'dos': ('','MSDOS'),
}

_architecture_split = re.compile(r'[\\s,]').split

def architecture(executable=sys.executable,bits='',linkage=''):

    \"\"\" Queries the given executable (defaults to the Python interpreter
        binary) for various architecture information.

        Returns a tuple (bits,linkage) which contains information about
        the bit architecture and the linkage format used for the
        executable. Both values are returned as strings.

        Values that cannot be determined are returned as given by the
        parameter presets. If bits is given as '', the sizeof(pointer)
        (or sizeof(long) on Python version < 1.5.2) is used as
        indicator for the supported pointer size.

        The function relies on the system's "file" command to do the
        actual work. This is available on most if not all Unix
        platforms. On some non-Unix platforms where the "file" command
        does not exist and the executable is set to the Python interpreter
        binary defaults from _default_architecture are used.

    \"\"\"
    # Use the sizeof(pointer) as default number of bits if nothing
    # else is given as default.
    if not bits:
        import struct
        try:
            size = struct.calcsize('P')
        except struct.error:
            # Older installations can only query longs
            size = struct.calcsize('l')
        bits = str(size*8) + 'bit'

    # Get data from the 'file' system command
    output = _syscmd_file(executable,'')

    if not output and \\
       executable == sys.executable:
        # "file" command did not return anything; we'll try to provide
        # some sensible defaults then...
        if _default_architecture.has_key(sys.platform):
            b,l = _default_architecture[sys.platform]
            if b:
                bits = b
            if l:
                linkage = l
        return bits,linkage

    # Split the output into a list of strings omitting the filename
    fileout = _architecture_split(output)[1:]

    if 'executable' not in fileout:
        # Format not supported
        return bits,linkage

    # Bits
    if '32-bit' in fileout:
        bits = '32bit'
    elif 'N32' in fileout:
        # On Irix only
        bits = 'n32bit'
    elif '64-bit' in fileout:
        bits = '64bit'

    # Linkage
    if 'ELF' in fileout:
        linkage = 'ELF'
    elif 'PE' in fileout:
        # E.g. Windows uses this format
        if 'Windows' in fileout:
            linkage = 'WindowsPE'
        else:
            linkage = 'PE'
    elif 'COFF' in fileout:
        linkage = 'COFF'
    elif 'MS-DOS' in fileout:
        linkage = 'MSDOS'
    else:
        # XXX the A.OUT format also falls under this class...
        pass

    return bits,linkage

### Portable uname() interface

_uname_cache = None

def uname():

    \"\"\" Fairly portable uname interface. Returns a tuple
        of strings (system,node,release,version,machine,processor)
        identifying the underlying platform.

        Note that unlike the os.uname function this also returns
        possible processor information as an additional tuple entry.

        Entries which cannot be determined are set to ''.

    \"\"\"
    global _uname_cache

    if _uname_cache is not None:
        return _uname_cache

    # Get some infos from the builtin os.uname API...
    try:
        system,node,release,version,machine = os.uname()

    except AttributeError:
        # Hmm, no uname... we'll have to poke around the system then.
        system = sys.platform
        release = ''
        version = ''
        node = _node()
        machine = ''
        processor = ''
        use_syscmd_ver = 1

        # Try win32_ver() on win32 platforms
        if system == 'win32':
            release,version,csd,ptype = win32_ver()
            if release and version:
                use_syscmd_ver = 0

        # Try the 'ver' system command available on some
        # platforms
        if use_syscmd_ver:
            system,release,version = _syscmd_ver(system)
            # Normalize system to what win32_ver() normally returns
            # (_syscmd_ver() tends to return the vendor name as well)
            if system == 'Microsoft Windows':
                system = 'Windows'

        # In case we still don't know anything useful, we'll try to
        # help ourselves
        if system in ('win32','win16'):
            if not version:
                if system == 'win32':
                    version = '32bit'
                else:
                    version = '16bit'
            system = 'Windows'

        elif system[:4] == 'java':
            release,vendor,vminfo,osinfo = java_ver()
            system = 'Java'
            version = string.join(vminfo,', ')
            if not version:
                version = vendor

        elif os.name == 'mac':
            release,(version,stage,nonrel),machine = mac_ver()
            system = 'MacOS'

    else:
        # System specific extensions
        if system == 'OpenVMS':
            # OpenVMS seems to have release and version mixed up
            if not release or release == '0':
                release = version
                version = ''
            # Get processor information
            try:
                import vms_lib
            except ImportError:
                pass
            else:
                csid, cpu_number = vms_lib.getsyi('SYI$_CPU',0)
                if (cpu_number >= 128):
                    processor = 'Alpha'
                else:
                    processor = 'VAX'
        else:
            # Get processor information from the uname system command
            processor = _syscmd_uname('-p','')

    # 'unknown' is not really any useful as information; we'll convert
    # it to '' which is more portable
    if system == 'unknown':
        system = ''
    if node == 'unknown':
        node = ''
    if release == 'unknown':
        release = ''
    if version == 'unknown':
        version = ''
    if machine == 'unknown':
        machine = ''
    if processor == 'unknown':
        processor = ''
    _uname_cache = system,node,release,version,machine,processor
    return _uname_cache

### Direct interfaces to some of the uname() return values

def system():

    \"\"\" Returns the system/OS name, e.g. 'Linux', 'Windows' or 'Java'.

        An empty string is returned if the value cannot be determined.

    \"\"\"
    return uname()[0]

def node():

    \"\"\" Returns the computer's network name (which may not be fully
        qualified)

        An empty string is returned if the value cannot be determined.

    \"\"\"
    return uname()[1]

def release():

    \"\"\" Returns the system's release, e.g. '2.2.0' or 'NT'

        An empty string is returned if the value cannot be determined.

    \"\"\"
    return uname()[2]

def version():

    \"\"\" Returns the system's release version, e.g. '#3 on degas'

        An empty string is returned if the value cannot be determined.

    \"\"\"
    return uname()[3]

def machine():

    \"\"\" Returns the machine type, e.g. 'i386'

        An empty string is returned if the value cannot be determined.

    \"\"\"
    return uname()[4]

def processor():

    \"\"\" Returns the (true) processor name, e.g. 'amdk6'

        An empty string is returned if the value cannot be
        determined. Note that many platforms do not provide this
        information or simply return the same value as for machine(),
        e.g.  NetBSD does this.

    \"\"\"
    return uname()[5]

### Various APIs for extracting information from sys.version

_sys_version_parser = re.compile(r'([\\w.+]+)\\s*'
                                  '\\(#?([^,]+),\\s*([\\w ]+),\\s*([\\w :]+)\\)\\s*'
                                  '\\[([^\\]]+)\\]?')
_sys_version_cache = None

def _sys_version():

    \"\"\" Returns a parsed version of Python's sys.version as tuple
        (version, buildno, builddate, compiler) referring to the Python
        version, build number, build date/time as string and the compiler
        identification string.

        Note that unlike the Python sys.version, the returned value
        for the Python version will always include the patchlevel (it
        defaults to '.0').

    \"\"\"
    global _sys_version_cache

    if _sys_version_cache is not None:
        return _sys_version_cache
    version, buildno, builddate, buildtime, compiler = \\
             _sys_version_parser.match(sys.version).groups()
    builddate = builddate + ' ' + buildtime
    l = string.split(version, '.')
    if len(l) == 2:
        l.append('0')
        version = string.join(l, '.')
    _sys_version_cache = (version, buildno, builddate, compiler)
    return _sys_version_cache

def python_version():

    \"\"\" Returns the Python version as string 'major.minor.patchlevel'

        Note that unlike the Python sys.version, the returned value
        will always include the patchlevel (it defaults to 0).

    \"\"\"
    return _sys_version()[0]

def python_version_tuple():

    \"\"\" Returns the Python version as tuple (major, minor, patchlevel)
        of strings.

        Note that unlike the Python sys.version, the returned value
        will always include the patchlevel (it defaults to 0).

    \"\"\"
    return string.split(_sys_version()[0], '.')

def python_build():

    \"\"\" Returns a tuple (buildno, builddate) stating the Python
        build number and date as strings.

    \"\"\"
    return _sys_version()[1:3]

def python_compiler():

    \"\"\" Returns a string identifying the compiler used for compiling
        Python.

    \"\"\"
    return _sys_version()[3]

### The Opus Magnum of platform strings :-)

_platform_cache = {}

def platform(aliased=0, terse=0):

    \"\"\" Returns a single string identifying the underlying platform
        with as much useful information as possible (but no more :).

        The output is intended to be human readable rather than
        machine parseable. It may look different on different
        platforms and this is intended.

        If "aliased" is true, the function will use aliases for
        various platforms that report system names which differ from
        their common names, e.g. SunOS will be reported as
        Solaris. The system_alias() function is used to implement
        this.

        Setting terse to true causes the function to return only the
        absolute minimum information needed to identify the platform.

    \"\"\"
    result = _platform_cache.get((aliased, terse), None)
    if result is not None:
        return result

    # Get uname information and then apply platform specific cosmetics
    # to it...
    system,node,release,version,machine,processor = uname()
    if machine == processor:
        processor = ''
    if aliased:
        system,release,version = system_alias(system,release,version)

    if system == 'Windows':
        # MS platforms
        rel,vers,csd,ptype = win32_ver(version)
        if terse:
            platform = _platform(system,release)
        else:
            platform = _platform(system,release,version,csd)

    elif system in ('Linux',):
        # Linux based systems
        distname,distversion,distid = dist('')
        if distname and not terse:
            platform = _platform(system,release,machine,processor,
                                 'with',
                                 distname,distversion,distid)
        else:
            # If the distribution name is unknown check for libc vs. glibc
            libcname,libcversion = libc_ver(sys.executable)
            platform = _platform(system,release,machine,processor,
                                 'with',
                                 libcname+libcversion)
    elif system == 'Java':
        # Java platforms
        r,v,vminfo,(os_name,os_version,os_arch) = java_ver()
        if terse:
            platform = _platform(system,release,version)
        else:
            platform = _platform(system,release,version,
                                 'on',
                                 os_name,os_version,os_arch)

    elif system == 'MacOS':
        # MacOS platforms
        if terse:
            platform = _platform(system,release)
        else:
            platform = _platform(system,release,machine)

    else:
        # Generic handler
        if terse:
            platform = _platform(system,release)
        else:
            bits,linkage = architecture(sys.executable)
            platform = _platform(system,release,machine,processor,bits,linkage)

    _platform_cache[(aliased, terse)] = platform
    return platform

### Command line interface

if __name__ == '__main__':
    # Modified to return our desired platform string, R. Graciani
    platformTuple = (system(),machine())
    if platformTuple[0] == 'Linux':
      # get version of higher libc installed
      if machine().find('64') != -1:
        lib = '/lib64'
      else:
        lib = '/lib'
      libs = []
      for lib in os.listdir(lib):
        if lib.find('libc-') == 0 or lib.find('libc.so') == 0 : libs.append(os.path.join('/lib',lib))
      libs.sort()
      platformTuple += ( '-'.join(libc_ver(libs[-1])),)
      # platformTuple += ( '-'.join(libc_ver('/lib/libc.so.6')),)
    elif platformTuple[0] == 'Darwin':
      platformTuple += ( '.'.join(mac_ver()[0].split(".")[:2]),)
    elif platformTuple[0] == 'Windows':
      platformTuple += ( win32_ver()[0],)
    else:
      platfromTuple += ( release() )

    platform = "%s_%s_%s" % platformTuple

    print platform
    sys.exit(0)

    # Default is to print the aliased verbose platform string
    terse = ('terse' in sys.argv or '--terse' in sys.argv)
    aliased = (not 'nonaliased' in sys.argv and not '--nonaliased' in sys.argv)
    print platform(aliased,terse)
    sys.exit(0)
""")
      f.close()
      os.chmod( platformFile, stat.S_IRWXU )
    except Exception, x:
      self.logERROR( 'Can not create "%s"' % platformFile )
      self.logEXCEP( x )
      
  def scriptOutput(self, scriptName, exitOnError=True, interpreter=None):
    """
     Execute a script from the scripts directory and return its output
    """
    diracScript = os.path.join( self.scriptsPath, scriptName )
    if not os.path.exists( diracScript ):
      if exitOnError:
        self.logERROR( 'Missing file %s' % diracScript )
        sys.exit(-1)
      else:
        return ''
    if interpreter:
      (child_stdout, child_stdin) = popen2.popen2( '%s %s' % ( interpreter, diracScript) )
    else:
      (child_stdout, child_stdin) = popen2.popen2( diracScript )
    stdout = child_stdout.read().strip()
    child_stdout.close()
    return stdout

  def alarmHandler(*args):
    """
     signal handler for SIGALRM, just raise an exception
    """
    raise Exception( 'TimeOut' )
  
  def cleanDir( dir ):
    """
     Walk the given directory and remove all .pyc and .pyo files
    """
    for d in os.walk( dir ):
      subDir = d[0]
      for f in d[2]:
        if f.endswith('.pyc'):
          os.remove( os.path.join(subDir,f) )
        elif f.endswith('.pyo'):
          os.remove( os.path.join(subDir,f) )

def exit( ret ):
  """
   Remove tmpDir and exit
  """
  dirac.logINFO( 'Remember to remove temporary Directory "%s"' % rootPath )
  sys.exit( ret )

dirac = Dirac( myFullName )

dirac.logINFO( 'Running "%s" version "%s"' % ( myShortName, __VERSION__) )

if myShortName in [ 'dirac-install', 'dirac-update']:

  if myShortName == 'dirac-install':
    dirac.cleanScripts()

  parse_options_install()
  dirac.logINFO( 'Checking DIRAC installation at "%s"' %  dirac.root() )

  if not dirac.localPlatform:
    dirac.platform()  
  dirac.logINFO( 'Using platform "%s"' %  dirac.localPlatform )
  
  if uploadFlag:
    dirac.build()
    tars = dirac.createSrcTars()
    tars = dirac.createBinTars()
    # name = 'DIRAC-lcg-%s-%s-%s' % ( lcgVer, dirac.localPlatform, dirac.python )
    # dirac._getTar( name, externalTimeout )
    if tars > 0:
      for file in os.listdir( dirac.root() ):
        if file.find('.tar.gz') != -1 :
          os.system( 'lcg-cp file:%s/%s gsiftp://lcg-se.ecm.ub.es/flatfiles/lhcb/distribution/%s' % ( dirac.root(), file, file ) )
  else:
    if not dirac.checkInterpreter():
      dirac.installExternal()
  
  dirac.checkDirac( )
  
  updateScript = os.path.join( dirac.root(), 'scripts', 'dirac-update' )
  distroScript = os.path.join( dirac.root(), 'scripts', 'dirac-distribution' )
  newScript = os.path.join( dirac.root(), 'scripts', 'dirac-install' )
  if os.path.exists( newScript ):
    shutil.copy( newScript, updateScript )
    shutil.move( newScript, distroScript )

  if dirac.checkInterpreter():
    dirac.logINFO( 'DIRAC-platform = %s' % dirac.localPlatform )
    dirac.lhcbPlatform()
  
    # dirac.checkDirac( )
    from DIRACEnvironment import DIRAC
    if dirac.debugFlag:
      DIRAC.gLogger.setLevel( 'DEBUG' )
    else:
      DIRAC.gLogger.setLevel( 'INFO' )
  
    from DIRAC.Core.Base import Script
  
    Script.registerSwitch( "b",  "build",     "Allow compilation if platform not available" )
    Script.registerSwitch( "d",  "debug",     "Set debug flag" )
    Script.registerSwitch( "e:", "external=", "DIRAC-external <version> to install" )
    Script.registerSwitch( "i:", "python=",   "Use python<24|25> interpreter" )
    Script.registerSwitch( "n:", "name=",     "Set <Site> as Site Name" )
    Script.registerSwitch( "p:", "platform=", "Use <platform> instead of local one" )
    Script.registerSwitch( "u:", "url=",      "Use <url> to download tarballs" )
    Script.registerSwitch( "v:", "version=",  "DIRAC <version> to install" )
    Script.registerSwitch( "C",  "cvs",       "Retrieve from CVS (implies -b)" )
    Script.registerSwitch( "N:", "Name=",     "Use <CEName> to determine Site Name" )
    Script.registerSwitch( "P:", "path=",     "Install under <root>" )
    Script.registerSwitch( "S",  "server",    "Make a full server installation" )
    Script.registerSwitch( "U",  "Upload",    "Upload compiled distribution to lhcbweb (if -b)" )
  
    from DIRAC.ConfigurationSystem.Client.LocalConfiguration import LocalConfiguration
    localCfg = LocalConfiguration()
    localCfg.addDefaultEntry( '/DIRAC/Setup', 'LHCb-Production' )
    localCfg.addDefaultEntry( '/DIRAC/Configuration/Servers',
                              'dips://lhcbprod.pic.es:9135/Configuration/Server, '
                              'dips://volhcb09.cern.ch:9135/Configuration/Server' )
    if dirac.lhcb_platform == 'ERROR' and DIRAC.platformTuple[0] == 'Linux':
      if DIRAC.platformTuple[1] == 'i686':
        arch = 'ia32'
      elif DIRAC.platformTuple[1] == 'x86_64':
        arch = 'amd64'
      else:
        arch = DIRAC.platformTuple[1]
      if DIRAC.platformTuple[2] >= '2.3.4':
        arch = 'slc4_'+arch+'_gcc34'
      elif DIRAC.platformTuple[2] >= '2.3.3':
        arch = 'slc3_'+arch+'_gcc323'
      else:
        arch = 'rh73_'+arch+'_gcc296'
      localCfg.addDefaultEntry( '/LocalSite/Architecture', arch )
    else:
      localCfg.addDefaultEntry( '/LocalSite/Architecture', dirac.lhcb_platform )
    localCfg.addDefaultEntry( '/LocalSite/CPUScalingFactor', '0.0' )
    localCfg.addDefaultEntry( '/LocalSite/Root', dirac.root() )
    if not dirac.serverFlag:
      localCfg.addDefaultEntry( '/DIRAC/Security/UseServerCertificate', 'no' )
    if siteName:
      localCfg.addDefaultEntry( '/LocalSite/Site', siteName )
      dirac.logINFO( 'Setting /LocalSite/Site = %s' % siteName )
  
    Script.parseCommandLine( script = myShortName, ignoreErrors = True )
  
    if ceName:
      siteSections = DIRAC.gConfig.getSections('/Resources/Sites/LCG/')
      if not siteSections['OK']:
        dirac.logEXCEP('Could not get LCG site list')
  
      siteName = None
      sites = siteSections['Value']
      for site in sites:
        lcgCEs = DIRAC.gConfig.getValue('/Resources/Sites/LCG/%s/CE' %site,[])
        if ceName in lcgCEs:
          siteName = site
          break
      if not siteName:
        dirac.logEXCEP('Could not determine DIRAC site name for CE:', siteName)
  
      dirac.logINFO( 'Setting /LocalSite/Site = %s' % siteName )
      localCfg.addDefaultEntry( '/LocalSite/Site', siteName )
      dirac.logINFO( 'Setting /LocalSite/GridCE = %s' % ceName )
      localCfg.addDefaultEntry( '/LocalSite/GridCE', ceName )
  
    if siteName:
      localSE = DIRAC.gConfig.getValue( '/Resources/Sites/LCG/%s/SE' % siteName, 'None' )
      localCfg.addDefaultEntry( '/LocalSite/LocalSE', localSE )
      dirac.logINFO( 'Setting /LocalSite/LocalSE = %s' % localSE )
  
    Script.parseCommandLine( script = myShortName, ignoreErrors = True )
  
  
    # further checks can be implemented here
    try:
      import bz2
    except:
      dirac.logERROR( 'Can not import bz2 module' )
      dirac.logEXCEP( x )
    diracSetup = DIRAC.gConfig.getValue( '/DIRAC/Setup' )
    dirac.logINFO( 'Setting /DIRAC/Setup = %s' % diracSetup )
  
    DIRAC.gConfig.dumpLocalCFGToFile( dirac.checkDiracCfg() )
    dirac.logINFO( 'DIRAC version "%s" installed' % dirac.version )
    dirac.logINFO( 'DIRAC-external version "%s" installed' % dirac.external )
  
    # curScript = os.path.join( dirac.root(), 'scripts', 'dirac-update' )
    # newScript = os.path.join( dirac.root(), 'scripts', 'dirac-install' )
    # if os.path.exists( newScript ):
    #  shutil.move( newScript, curScript )
      
  
    sys.exit(0)
    
  else:

    dirac.logINFO( 'Will retry now with DIRAC python' )
    quotedArgs = []
    for arg in sys.argv[1:]:
      if arg.find(' ') > -1:
        quotedArgs.append('"%s"' % arg.replace('"','\"'))
      else:
        quotedArgs.append(arg)
    args         = str.join(' ',quotedArgs) + ' -v %s' % dirac.version
    if os.path.exists( dirac.localPython ):
      myCmd = '%s %s %s ' % ( dirac.localPython, updateScript, args )
    else:
      # try installed python instead (it might be compatible
      myCmd = '%s %s %s ' % ( dirac.installedPython, updateScript, args )
    # to be removed
    # if os.path.realpath( sys.argv[0] ) != os.path.realpath( myScript ):
    #   shutil.copy( sys.argv[0], myScript )
    # 
    # shutil.copy( sys.argv[0], distroScript )
    dirac.logDEBUG( myCmd )
    sys.exit( os.system( myCmd ) / 256 )

elif myShortName in ['dirac-distribution']:
  # by default use CVS repository
  dirac.cvsFlag()
  # Parse Command line
  parse_options_distro()
  # get a tmp Root path to prepare the distribution
  rootPath = dirac.tmpDir()
  # determine local platform
  dirac.platform()

  dirac.logINFO( 'Preparing DIRAC distribution at "%s"' %  dirac.root() )
  if dirac.buildFlag:
    dirac.logINFO( 'Using platform "%s"' %  dirac.localPlatform )
  
  tars =  dirac.createSrcTars()
  tars += dirac.createBinTars()

  if tars > 0:
    dirac.logINFO( 'Upload tar files to repository:' )
    dirac.logINFO( " ( cd %s ; tar -cf - *.tar.gz ) | ssh lhcbprod@lxplus.cern.ch 'cd /afs/cern.ch/lhcb/distribution/DIRAC3 &&  tar -xvf - && ls *.tar.gz > DIRAC.list'" % rootPath )
    dirac.logINFO( " ( cd %s ; tar -cf - *.tar.gz ) | gsissh -p 1975 lhcbweb.pic.es 'cd /opt/dirac/webRoot/distribution/DIRAC3 &&  tar -xvf - && ls *.tar.gz > DIRAC.list'" % rootPath )
  exit(0)
  
else:
  dirac.logERROR( 'Not recognized script name, exiting' )
  exit(-1)
