#!/usr/bin/env python
########################################################################
# $Header: /tmp/libdirac/tmp.stZoy15380/dirac/DIRAC3/scripts/dirac-install,v 1.58 2008/06/17 10:08:35 rgracian Exp $
# File :   dirac-install
# Author : Ricardo Graciani
########################################################################
__RCSID__   = "$Id: dirac-install,v 1.58 2008/06/17 10:08:35 rgracian Exp $"
__VERSION__ = "$Revision: 1.58 $"
"""
    Script to prepare/update a DIRAC instalation
"""
tmpPath  = None
siteName = None
ceName   = None
uploadFlag = False

functionVersion = "1.70"

try:
  import dirac_functions
  if dirac_functions.__VERSION__.find( functionVersion ) == -1:
    print >> sys.stderr, 'Wrong version of dirac_functions.py'
    Exception( 'Wrong version of dirac_functions.py' )
  from dirac_functions import functions
except:
  try:
    # if dirac_function is not available, retrive DIRAC-scripts tar
    import sys, os, signal, time, shutil
    import tempfile, urllib
    defaultURL = 'http://cern.ch/lhcbproject/dist/DIRAC3'
    # defaultURL = 'http://lhcbweb.pic.es/distribution/DIRAC3'
    cwdPath = os.getcwd()
    try:
      tmpPath = tempfile.mkdtemp( 'tmp', 'DIRAC3')
    except:
      tmpPath = tempfile.mktemp()
      os.mkdir( tmpPath )
    os.chdir( tmpPath )
    def _getTar( name, timeout ):
      try:
        ( file, localName ) = tempfile.mkstemp()
      except:
        localName = tempfile.mktemp()
      tarFileName = os.path.join( '%s.tar.gz' % name )
      remoteName = '%s/%s' % ( defaultURL, tarFileName )
      error = 'Retrieving file "%s"' % remoteName
      urlretrieveTimeout( remoteName, localName, timeout )
      try:
        error = 'Opening file "%s"' % localName
        import tarfile
        tar = tarfile.open( localName , 'r' )
        try:
          error = 'Extracting file "%s"' % localName
          tar.extractall( tmpPath )
          os.remove( localName )
        except:
          for member in tar.getmembers():
            tar.extract( member, tmpPath )
          os.remove( localName )
    
      except Exception, x:
        try:
          error = 'Extracting file "%s"' % localName
          ret = os.system( 'tar xzf %s' % localName )
          if ret != 0:
            raise Exception( 'Fail to extract tarfile'  )
          os.remove( localName )
          return
        except Exception, x:
          pass
        logERROR( error )
        logEXCEP( x )

    def urlretrieveTimeout( fname, lname, timeout ):
      """
       Retrive remore url to local file, with timeout wrapper
      """
      # NOTE: Not thread-safe, since all threads will catch same alarm.
      #       This is OK for dirac-install, since there are no threads.
      logINFO( 'Retrieving remote file "%s"' % fname )
    
      signal.signal(signal.SIGALRM, alarmHandler)
      # set timeout alarm
      signal.alarm(timeout)
      try:
        localname,headers = urllib.urlretrieve( fname, lname )
      except Exception, x:
        if x == 'TimeOut':
          logERROR( 'Timeout after %s seconds on transfer request for "%s"' % \
          (str(timeout), fname) )
        raise x
    
      # clear timeout alarm
      signal.alarm(0)
      
    def alarmHandler(*args):
      """
       signal handler for SIGALRM, just raise an exception
      """
      raise Exception( 'TimeOut' )

    def log( level, msg ):
      """
       Print log entries similar to DIRAC Logger
      """
      shortName = os.path.basename(sys.argv[0])
      logTime = time.strftime('%Y-%m-%d %H:%M:%S',time.gmtime()) + " UTC"
      # logTime = str( datetime.datetime.utcnow( ) ).split('.')[0] + " UTC"
      for line in msg.split( '\n' ):
        print logTime, shortName, level, line
    def logEXCEP( msg ):
      log( 'EXCEPT', str(msg) )
      sys.exit( -1 )
    def logERROR( msg ):
      log( 'ERROR ', msg )
    def logINFO( msg ):
      log( 'INFO  ', msg )
    def logDEBUG( msg ):
      log( 'DEBUG ', msg )

    _getTar( 'DIRAC-scripts-HEAD', 60 )
    sys.path.insert( 0, os.path.join( tmpPath, 'scripts' ) )
    
  except Exception, x:
    print >> sys.stderr, 'ERROR python interpreter does not support necessary modules'
    print >> sys.stderr, 'ERROR', x
    print >> sys.stderr, ''
    sys.exit(-1)


def parse_options():
  """
   parse command line options:
  """
  import getopt
  global dirac, siteName, ceName, uploadFlag
  help = """
   -b --build                  Force local compilation
   -d --debug                  Set debug flag
   -e --external=<version>     DIRAC-external <version> to install (overwrites -v)
   -h --help                   Print this
   -i --python=<24|25>         Use python<24|25> interpreter
   -n --name=<Site>            Set <Site> as Site Name
   -p --platform=<platform>    Use <platform> instead of local one
   -r --repository=<rep>       Use <rep> as cvs repository
   -u --url=<url>              Use <url> to download tarballs
   -v --version=<version>      DIRAC <version> to install
   -C --cvs                    Retrieve from CVS (implies -b)
   -N --Name=<CEName>          Use <CEName> to determine Site Name
   -P --path=<root>            Install under <root>
   -S --server                 Make a full server installation
   -U --Upload                 Upload compiled distribution to lhcbweb (if -b)

  from DIRAC framework:

    -o --option=<Option=value> <Option=value> to add
    -s --section=<section>     Set base <section> for relative parsed options
    -c --cert=<cert>           Use server certificate <cert> to connect to Core Services

  """
  shortOptions = 'bde:hi:n:p:r:u:v:o:s:CN:P:SU'
  longOptions  = ['build', 'debug', 'external=', 'help', 'python=', 'name', 
                  'platform=', 'repository=', 'url=', 'version=', 
                  'cvs', 'Name=', 'path=', 'server', 'Upload',
                  'option=', 'section=', 'cert=']
  try:
    ( optionVals, extraOptions ) = getopt.getopt( sys.argv[1:], shortOptions, longOptions )
  except getopt.GetoptError, x:
    dirac.logERROR( 'Parsing command line: %s' % x )
    optionVals = [ ('-h','') ]

  if ('-h','') in optionVals or ('--help','') in optionVals:
    dirac.logHelp( help )

  ext = None
    
  for o,v in optionVals:
    if o == '-b' or o == '--build':
      dirac.build()
    elif o == '-d' or o == '--debug':
      dirac.debug()
    elif o == '-e' or o == '--external':
      ext = v
    elif o == '-i' or o == '--python':
      dirac.setPython(v)
    elif o == '-n' or o == '--name':
      siteName = v
    elif o == '-p' or o == '--platform':
      dirac.platform(v)
    elif o == '-r' or o == '--repository':
      dirac.setCVS(v)
    elif o == '-u' or o == '--url':
      dirac.setURL( v )
    elif o == '-v' or o == '--version':
      dirac.setVersion(v)
    elif o == '-C' or o == '--cvs':
      dirac.cvsFlag()
      dirac.build()
    elif o == '-N' or o == '--Name':
      ceName = v
    elif o in ('-P', '--path'):
      dirac.setRoot( os.path.join( v, 'scripts', myShortName ) )
    elif o == '-S' or o == '--server':
      dirac.requireServer()
    elif o == '-U' or o == '--Upload':
      uploadFlag = True

    if ext: dirac.setExternal(ext)

import os, sys, shutil
import dirac_functions
if dirac_functions.__VERSION__.find( functionVersion ) == -1:
  print >> sys.stderr, '%s was not up-to-date, it has now been updated' % sys.argv[0]
  print >> sys.stderr, ' Run again the same command'
  curScript = os.path.join( cwdPath, sys.argv[0] )
  newScript = os.path.join( 'scripts', 'dirac-install' )
  shutil.move( newScript, curScript )
  sys.exit(2)

from dirac_functions import functions, lcgVer, externalTimeout
  
if not tmpPath:
  myFullName  = os.path.realpath( sys.argv[0] )
  myShortName = os.path.basename( myFullName )
else:
  myShortName = os.path.basename( sys.argv[0] )
  myFullName = os.path.join( tmpPath, 'scripts', myShortName )

# use a different LCG version
dirac_functions.lcgVer = "3.1.10-0-new"

dirac = functions( myFullName )
# by default install from tar
dirac.tarFlag()

parse_options()
if not dirac.localPlatform:
  dirac.platform()

if tmpPath:
  # if dirac_functions could not be imported, install by default at current
  # working directory.
  dirac.setRoot( os.path.join( cwdPath, 'scripts', myShortName ) )

dirac.logINFO( 'Checking DIRAC instalation at "%s"' %  dirac.root() )
dirac.logINFO( 'Using platform "%s"' %  dirac.localPlatform )

if not dirac.checkInterpreter( ):
  if uploadFlag:
    dirac.build()
    tars = dirac.createSrcTars()
    tars = dirac.createBinTars()
    # name = 'DIRAC-lcg-%s-%s-%s' % ( lcgVer, dirac.localPlatform, dirac.python )
    # dirac._getTar( name, externalTimeout )
    if tars > 0:
      for file in os.listdir( dirac.root() ):
        if file.find('.tar.gz') != -1 :
          os.system( 'lcg-cp file:%s/%s gsiftp://lcg-se.ecm.ub.es/flatfiles/lhcb/distribution/%s' % ( dirac.root(), file, file ) )
  else:
    dirac.installExternal()
  dirac.checkDirac( )
  dirac.diracMagic(  '#! %s' % dirac.localPython )
  # if we are not running with our onw python let's call ourself again
  dirac.logINFO( 'Will retry now with DIRAC python' )
  args         = str.join(' ',sys.argv[1:]) + ' -v %s' % dirac.version
  myScript = os.path.join( dirac.root(),'scripts', myShortName )
  myCmd = '%s %s %s ' % ( dirac.localPython, myScript, args )
  dirac.logDEBUG( myCmd )
  ret = os.system( myCmd )
  sys.exit(ret)

else:
  dirac.logINFO( 'DIRAC-platform = %s' % dirac.localPlatform )

  dirac.checkDirac( )
  dirac.diracMagic(  '#! %s' % dirac.localPython )
  from DIRACEnvironment import DIRAC
  if dirac.debugFlag:
    DIRAC.gLogger.setLevel( 'DEBUG' )
  else:
    DIRAC.gLogger.setLevel( 'INFO' )
  from DIRAC.Core.Utilities.GridCredentials import setDIRACGroup
  
  setDIRACGroup( 'lhcb_user' )
  
  from DIRAC.Core.Base import Script

  Script.registerSwitch( "b",  "build",     "Allow compilation if platform not available" )
  Script.registerSwitch( "d",  "debug",     "Set debug flag" )
  Script.registerSwitch( "e:", "external=", "DIRAC-external <version> to install" )
  Script.registerSwitch( "i:", "python=",   "Use python<24|25> interpreter" )
  Script.registerSwitch( "n:", "name=",     "Set <Site> as Site Name" )
  Script.registerSwitch( "p:", "platform=", "Use <platform> instead of local one" )
  Script.registerSwitch( "u:", "url=",      "Use <url> to download tarballs" )
  Script.registerSwitch( "v:", "version=",  "DIRAC <version> to install" )
  Script.registerSwitch( "C",  "cvs",       "Retrieve from CVS (implies -b)" )
  Script.registerSwitch( "N:", "Name=",     "Use <CEName> to determine Site Name" )
  Script.registerSwitch( "P:", "path=",     "Install under <root>" )
  Script.registerSwitch( "S",  "server",    "Make a full server installation" )
  Script.registerSwitch( "U",  "Upload",    "Upload compiled distribution to lhcbweb (if -b)" )
  
  from DIRAC.ConfigurationSystem.Client.LocalConfiguration import LocalConfiguration
  localCfg = LocalConfiguration()
  localCfg.addDefaultEntry( '/DIRAC/Setup', 'LHCb-Development' )
  localCfg.addDefaultEntry( '/DIRAC/Configuration/Servers',
                            'dips://lhcbprod.pic.es:9135/Configuration/Server, '
                            'dips://volhcb01.cern.ch:9135/Configuration/Server' )
  if dirac.architecture == 'ERROR' and DIRAC.platformTuple[0] == 'Linux':
    if DIRAC.platformTuple[1] == 'i686':
      arch = 'ia32'
    elif DIRAC.platformTuple[1] == 'x86_64':
      arch = 'amd64'
    else:
      arch = DIRAC.platformTuple[1]
    if DIRAC.platformTuple[2] >= '2.3.4':
      arch = 'slc4_'+arch+'_gcc34'
    elif DIRAC.platformTuple[2] >= '2.3.3':
      arch = 'slc3_'+arch+'_gcc323'
    else:
      arch = 'rh73_'+arch+'_gcc296'
    localCfg.addDefaultEntry( '/LocalSite/Architecture', arch )
  else:
    localCfg.addDefaultEntry( '/LocalSite/Architecture', dirac.architecture )
  localCfg.addDefaultEntry( '/LocalSite/CPUScalingFactor', '0.0' )
  localCfg.addDefaultEntry( '/LocalSite/Root', dirac.root() )
  if not dirac.serverFlag:
    localCfg.addDefaultEntry( '/DIRAC/Security/UseServerCertificate', 'no' )
  if siteName:
    localCfg.addDefaultEntry( '/LocalSite/Site', siteName )
  Script.parseCommandLine( script = myShortName, ignoreErrors = True )

  
  # further checks can be implemented here
  try:
    import bz2
  except:
    dirac.logERROR( 'Can not import bz2 module' )
    dirac.logEXCEP( x )
  diracSetup = DIRAC.gConfig.getValue( '/DIRAC/Setup' )
  dirac.logINFO( 'Setting /DIRAC/Setup = %s' % diracSetup )
  if ceName:
    diracCE = DIRAC.gConfig.getValue( '/Resources/GridSites/LCG/%s' % ceName, 'Unknown' )
    dirac.logINFO( 'Setting /LocalSite/Site = %s' % diracCE )
    localCfg.addDefaultEntry( '/LocalSite/Site', diracCE )
    localSE = DIRAC.gConfig.getValue( '/Resources/SiteLocalSEMapping/%s' % diracCE, 'None' )
    localCfg.addDefaultEntry( '/LocalSite/LocalSE', localSE )
    dirac.logINFO( 'Setting /LocalSite/LocalSE = %s' % localSE )
    Script.parseCommandLine( script = myShortName, ignoreErrors = True )

  DIRAC.gConfig.dumpLocalCFGToFile( dirac.checkDiracCfg() )
  dirac.logINFO( 'DIRAC version "%s" installed' % dirac.version )
  dirac.logINFO( 'DIRAC-external version "%s" installed' % dirac.external )

  curScript = os.path.join( dirac.root(), 'scripts', 'dirac-update' )
  newScript = os.path.join( dirac.root(), 'scripts', 'dirac-install' )
  if os.path.exists( newScript ):
    shutil.move( newScript, curScript )

  sys.exit(0)
