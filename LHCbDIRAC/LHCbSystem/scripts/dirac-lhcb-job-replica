#! /usr/bin/env python
########################################################################
# $Header: /tmp/libdirac/tmp.stZoy15380/dirac/DIRAC3/LHCbSystem/scripts/Attic/dirac-lhcb-job-replica,v 1.4 2008/08/19 09:21:31 roma Exp $
# File :   dirac-production-job-delete
# Author : Stuart Paterson
########################################################################
__RCSID__   = "$Id: dirac-lhcb-job-replica,v 1.4 2008/08/19 09:21:31 roma Exp $"
__VERSION__ = "$Revision: 1.4 $"
from DIRAC.Core.Base                                         import Script
from DIRACEnvironment                                        import DIRAC

Script.registerSwitch( "S:", "Status=", "Status [Stalled]" )
Script.registerSwitch( "A:", "ApplicationStatus=", "ApplicationStatus [None (All)]" )
Script.registerSwitch( "M:", "MinorStatus=", "MinorStatus [None (All)]" )
Script.registerSwitch( "C:", "Site=", "Site [None (All)]" )
Script.registerSwitch( "O:", "Owner=", "Owner [None (All)]" )
Script.registerSwitch( "J:", "JobGroup=", "JobGroup [None (All)]" )
Script.registerSwitch( "D:", "Date=", "Date [None (Today)]" )

from DIRAC.Interfaces.API.Dirac                              import Dirac
from DIRAC.Interfaces.API.Job                                import Job

Script.parseCommandLine( ignoreErrors = True )
args = Script.getPositionalArgs()

def usage():
  print 'Usage: %s ' %(Script.scriptName)
  DIRAC.exit(2)

if len(args) > 0:
  usage()

def getLFNRoot(lfn,mcYear=0):
  """
  return the root path of a given lfn

  eg : /lhcb/data/CCRC08/00009909 = getLFNRoot(/lhcb/data/CCRC08/00009909/DST/0000/00009909_00003456_2.dst)
  eg : /lhcb/MC/<year>/  = getLFNRoot(None)
  """

  dataTypes = ['SIM','DIGI','DST','RAW','ETC','SETC','FETC','RDST','MDF']

  if lfn:
    for inputname in lfn.split(';'):
      for datatype in dataTypes:
        position = inputname.find(datatype)
        if position >-1:
          return inputname[:position-1]
          
  elif mcYear=='DC06': #This should be reviewed.
    return '/lhcb/production/DC06'
  else:
    return '/lhcb/MC/'+str(mcYear)
    
def makeProductionLfn(JOB_ID,LFN_ROOT,filetuple,mode,prodstring,prodConfig='phys-v4-lumi2'):
  """ Constructs the logical file name according to LHCb conventions.
  Returns the lfn without 'lfn:' prepended
  """
  try:
    jobindex = "%04d"%(int(JOB_ID)/10000)
  except:
    jobindex = '0000'

  fname = filetuple[0]

  if fname.count('lfn:'):
    return fname.replace('lfn:','')
  
  if fname.count('LFN:'):
    return fname.replace('LFN:','')

  if LFN_ROOT.count('DC06',): #This should be reviewed, is a nasty fix.
    return LFN_ROOT+'/'+prodConfig+'/'+prodstring+'/'+filetuple[1].upper()+'/'+jobindex+'/'+filetuple[0]

  return LFN_ROOT+'/'+filetuple[1].upper()+'/'+prodstring+'/'+jobindex+'/'+filetuple[0]


dirac=Dirac()

status = 'Stalled'
minorstatus = None
applicationstatus=None
site = None
owner = None
jobgroup=None
date = None

for unprocSw in Script.getUnprocessedSwitches():
  if unprocSw[0] in ( "S", "Status" ):
        status = unprocSw[1]
  if unprocSw[0] in ( "M", "MinorStatus" ):
        minorstatus = unprocSw[1]
  if unprocSw[0] in ( "A", "ApplicationStatus" ):
        applicationstatus = unprocSw[1]
  if unprocSw[0] in ( "C", "Site" ):
        site = unprocSw[1]
  if unprocSw[0] in ( "O", "Owner" ):
        owner = unprocSw[1]
  if unprocSw[0] in ( "J", "JobGroup" ):
        jobgroup = unprocSw[1]
  if unprocSw[0] in ( "D", "Date" ):
        date = unprocSw[1]


selectjobs = dirac.selectJobs(Status=status,
                              MinorStatus=minorstatus,
                              ApplicationStatus=applicationstatus,
                              Site = site,
                              Owner = owner,
                              JobGroup=jobgroup,
                              Date=date)
if not selectjobs['OK']:
  print selectjobs['Message']
  DIRAC.exit(2)

jobs = selectjobs['Value']
print len(jobs),"jobs were selected"
print jobs


from DIRAC.DataManagementSystem.Client.ReplicaManager import ReplicaManager
rm = ReplicaManager()

jobs_badstatus = []
jobs_badsandbox = []
jobs_badxml = []
jobs_badparameter = []
jobs_badreplica = []
jobs_withallreplica = []
jobs_withreplica = []
jobs_withoutreplica = []

import os

for job in jobs:
  result = dirac.status(int(job))
  if not result['OK']:
    print job, result['Message']
    jobs_badstatus.append(job)
    continue
    
  dirac.getInputSandbox(int(job))
  if not result['OK']:
    print job, result['Message']
    jobs_badsandbox.append(job)
    continue

  if not os.path.exists('InputSandbox%s/jobDescription.xml' %job):
    print job,"Can't find XML file"
    jobs_badxml.append(job)
    continue
  
  try:
    xml = open('InputSandbox%s/jobDescription.xml' %job).read()
  except Exception,x:
    print x
    jobs_badxml.append(job)
    continue
  
  j = Job(xml)
  jobid =  None
  prodid = None
  jobname = None
  output = None
  inputdata = None
  configversion = None
  
  for p in j.workflow.parameters:
    if p.getName() == "JOB_ID":
      jobid = p.getValue()
    if p.getName() == "PRODUCTION_ID":
      prodid = p.getValue()
    if p.getName() == "JobName":
      jobname = p.getValue()
    if p.getName() == "outputDataFileMask":
      output = p.getValue()
    if p.getName() == "InputData":
      inputdata = p.getValue()
    if p.getName() == "configVersion":
      configversion = p.getValue()

  if not jobid or not prodid or not jobname or not configversion:
    print "No jobid or prodid or jobname or output",jobid,prodid,jobname,output,inputdata,configversion
    jobs_badparameter.append(job)
    continue
  
  if inputdata:
    print "InputData",inputdata

  code = j.createCode()
#  print code
  listoutput = []
  for line in code.split("\n"):
    if line.count("listoutput"):
      listoutput += eval(line.split("#")[0].split("=")[-1]) 

  lfns = []
  for item in listoutput:
    if (not output) or item['outputDataType'] in output:
      filename = item['outputDataName']
      lfnroot = getLFNRoot(inputdata,configversion)
      lfn = makeProductionLfn(jobid,lfnroot,(filename,item['outputDataType']),'MODE',prodid)
      lfns.append(lfn)
          
  print "OutputData",lfns
  replicas = rm.getReplicas(lfns)  
  if replicas['OK']:
    value = replicas['Value']
    if value['Successful']:
      if len(value['Successful'])==len(lfns):
        jobs_withallreplica.append(job)
      else:
        jobs_withreplica.append(job)
    else:
      jobs_withoutreplica.append(job)
  else:
    jobs_badreplica.append(job)  


print 'jobs_badstatus',jobs_badstatus
print 'jobs_badsandbox',jobs_badsandbox
print 'jobs_badxml',jobs_badxml
print 'jobs_badparameter',jobs_badparameter
print 'jobs_badreplica',jobs_badreplica
print 'jobs_withallreplica',jobs_withallreplica
print 'jobs_withreplica',jobs_withreplica
print 'jobs_withoutreplica',jobs_withoutreplica
