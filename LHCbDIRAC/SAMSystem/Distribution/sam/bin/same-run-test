#!/usr/bin/env python

import os
import sys
import getopt
import time
import signal

# set SAME home directory assuming that executable is in SAME_HOME/bin
def setupHomeDir():
    global same_home
    if not os.environ.has_key('SAME_HOME'): 
	same_home=os.path.normpath(
	    os.path.dirname(os.path.abspath(sys.argv[0])) + "/..")
	os.environ['SAME_HOME']=same_home
    else:
	same_home=os.environ['SAME_HOME']
    sys.path.insert(1, same_home+'/lib/python')
    os.environ['PATH']=same_home+'/bin:'+os.environ['PATH']

# SIGALARM handler. This signal is set locally to the value of
# [submission].test_timeout defined in same.conf.
def sig_alrm(sig, stack):
    global process
    if process.isalive():
        os.kill(-process.pid, sig)
        process.term_timeout=True

# SIGTERM handler. The signal is usually sent by submission Scheduler 
# when [scheculer].default_timeout is reached (defined in same.conf).
def sig_term(sig, stack):
    global process
    sig_alrm(signal.SIGALRM, stack)
    process.sched_timeout=True

setupHomeDir()

from same.Config import config
from same.Sensor import setupTestsEnv

setupTestsEnv()

opts,args=getopt.getopt(sys.argv[1:],'v:n:t:e:d:o:s:',
			['vo=','node=','test=','env=','dir=','output=','script=',
                         'jobid=','starttime=','jobtest='])

opts_map={ '-v': 'voName', '--vo': 'voName',
	   '-n': 'nodeName', '--node': 'nodeName',
	   '-t': 'testName', '--test': 'testName',
	   '-e': 'envName', '--env': 'envName',
           '--jobid': 'jobID',
           '--starttime': 'startTime',
           '--jobtest': 'jobTestName'}

#req_attrs=['voName','nodeName','testName','envName']

usage="""Usage:
%s [options] [arguments]

where options are the following:
(service node tests)
-v|--vo <voName>
-n|--node <nodeName>
-t|--test <testName>    - mandatory option
-e|--env <envName>

(jobwrapper tests)
--jobid                 
--starttime
--jobtest

(general options)
-d|--dir <directory>    - the directory where test <testName> can be found
-o|--output <filename>  - the file to save result tuple
-s|--script <filename>  - the file to execute as test script (overriding testName)

This command runs a test script available as executable in 
<directory>/<testName>
the optional arguments are passed to the test script,
and the commands returns on the standard output a TestData tuple in the format
that can be accepted by "same-publish-tuples TestData" command.

"""%sys.argv[0]

dir=None
output=None
tuple={}
script=None
testcmd=None

for o,v in opts:
    if o in ('-t','--test'):
        testcmd=v
	tuple[opts_map[o]]=v.split()[0]
    elif o in ('-d','--dir'):
	dir=v
    elif o in ('-o','--output'):
        output=v
    elif o in ('-s','--script'):
        script=v
    elif opts_map.has_key(o):
	tuple[opts_map[o]]=v

if script:
    cmd=script+' '+' '.join(args).replace("'","")+' 2>&1'
elif testcmd:
    cmd=testcmd+' '+' '.join(args).replace("'","")+' 2>&1'
else:
    sys.stderr.write(usage)
    sys.exit(1)
        
if dir:
    cmd=dir+'/'+cmd

status_dict=dict(map(lambda x: (x,config.getint('statuscode',x)), ['ok','info','notice','warning','error','critical','maintenance']))

if os.environ.has_key("SAME_TIMEOUT"):
    test_timeout=int(os.environ["SAME_TIMEOUT"])
else:
    test_timeout=config.getint('submission', 'test_timeout')
signal.signal(signal.SIGTERM, sig_term)
signal.signal(signal.SIGALRM, sig_alrm)
signal.alarm(test_timeout)

# Try with Pexpect first. If it fails - fallback to popen().
try:
    from same.pexpectpgrp import spawnpgrp
    from pexpect import ExceptionPexpect, EOF, TIMEOUT

    read_timeout=30 # default value in Pexpect is 30 sec
    process=spawnpgrp(cmd,timeout=read_timeout)
    
    l=True
    lines=[]
    status=None
    retcode=None
    
    while l:
        try:
            l=process.readline()
        except TIMEOUT, e:
            if not process.isalive():
                lines+="\nTimed out after %.2f sec while waiting for stdout from child.\n"%(float(read_timeout))
                lines+="Child process(es) died.\n"
                break
        if not l:
            break
        else:
            lines.append(l)
            
    # Hack. Othervise obtaining of exit status and return code 
    # of the child process doesn't work properly.
    if process.isalive():
        pass
    
    for i in range(len(lines)):
        lines[i]='\n'.join(reduce(lambda x,y: x[:-1]+[y[0]+x[-1][len(y[0]):]]+y[1:], \
                                  [str(x).split('\n') for x in str(lines[i]).split('\r')]))
    
    # As we could not get any exeption (e.g., IOError) from Pexpect 
    # in case if child was sent a signal - lets rely on our variable 
    # set in signal handler. Otherwise, collect return code (exit status) 
    # and status from normally exited process.
    if process.term_timeout:
        # timeout from Scheduler
        if process.sched_timeout:
            sched_timeout=int(config.get('scheduler','default_timeout'))
            lines+="\nTimeout from scheduler when executing test %s after %d seconds! (test timeout %d)"% \
                (tuple['testName'], sched_timeout, test_timeout), "summary: scheduler timeout"
        else: # test timeout
            lines+="\nTimeout when executing test %s after %d seconds!"% \
                (tuple['testName'], test_timeout), "summary: test timeout"
        if testcmd == "CE-sft-job":
            status=process.status
            retcode=process.exitstatus
            #retcode=status_dict['warning']
        else:
            status=0
            retcode=status_dict['error']
    else:
        try:
            pid, status = os.waitpid(process.pid,os.WNOHANG)
        except OSError:
            status=process.status
        # exitstatus = os.WEXITSTATUS(status)
        # 'return code of application' == 'exit status'
        #retcode=process.exitstatus
        retcode=os.WEXITSTATUS(status)

except ExceptionPexpect:
    from same.popenpgrp import Popenpgrp

    process=Popenpgrp(cmd)

    l=True
    lines=[]
    status=None
    retcode=None
    
    while l:
        try:
            l=process.fromchild.readline()
        except IOError:
            lines+=process.fromchild.readlines()
            lines+="Timeout when executing test %s after %d seconds!"%(tuple['testName'],timeout),"summary: timeout"
            l=None
            retcode=status_dict['error']
        if l:
            lines.append(l)
    if not retcode:
        status=process.poll()
        while status<0:
            process.wait()
            status=process.poll()
        retcode=os.WEXITSTATUS(status)

if retcode:
    summaryData=None
    if lines and lines[-1].find("summary: ")==0:
        summaryData=lines[-1][9:].strip('\n')[:255]
        lines.pop()
    if not retcode in status_dict.values():
        lines+="Unknown test status code: %d (process status=%d)!!!\n"%(retcode, status)
        retcode=status_dict['error']
    if output:
        sys.stdout=open(output, "w")
    for attr, value in tuple.items():
        print attr+': '+value

    if tuple.has_key('jobID'):
        print 'testtime: '+str(int(time.time()))
        print "status: "+str(retcode)
        if summaryData:
            print "summary: "+summaryData
    else:
        print 'timestamp: '+str(int(time.time()))
        print "status: "+str(retcode)
        if summaryData:
            print "summaryData: "+summaryData
        print "detailedData: EOT"
        print ''.join(lines).strip('\n')
        print 'EOT'

sys.exit(retcode)
